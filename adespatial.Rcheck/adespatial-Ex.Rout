
R Under development (unstable) (2024-09-03 r87093) -- "Unsuffered Consequences"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "adespatial"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "adespatial-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('adespatial')
Registered S3 methods overwritten by 'adespatial':
  method             from       
  plot.multispati    adegraphics
  print.multispati   ade4       
  summary.multispati ade4       
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Cperiodogram")
> ### * Cperiodogram
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Cperiodogram
> ### Title: Contingency periodogram
> ### Aliases: Cperiodogram
> 
> ### ** Examples
> 
> # Data from the numerical example of Subsection 12.4.2 of Legendre and Legendre (2012).
> test.vec <- c(1,1,2,3,3,2,1,2,3,2,1,1,2,3,3,1)
> # Periodogram with tests using the chi-square distribution
> res <- Cperiodogram(test.vec)
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
Warning in chisq.test(tab, simulate.p.value = simulate, B = nperm) :
  Chi-squared approximation may be incorrect
> # Periodogram with permutation tests
> res <- Cperiodogram(test.vec, nperm=2000, graph=FALSE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Cperiodogram", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("LCBD.comp")
> ### * LCBD.comp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: LCBD.comp
> ### Title: Compute LCBD from any D matrix
> ### Aliases: LCBD.comp
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> ### Example 1
> ### Compute the Hellinger distance, then the LCBD indices.
> if(require("vegan", quietly = TRUE)){
+ data(mite)
+ mite.hel = decostand(mite, "hellinger")
+ mite.D = dist(mite.hel)
+ out.mite.D = LCBD.comp(mite.D, sqrt.D=FALSE)
+ }
This is vegan 2.6-6.1
> 
> ### Example 2
> if(require("ade4", quietly = TRUE) & require("adegraphics", quietly = TRUE)){
+ data(doubs)
+ fish.sp = doubs$fish[-8,]   # Fish data; site 8 is removed because no fish were caught
+ 
+ out.comp = beta.div.comp(fish.sp, coef="S", quant=TRUE)
+ 
+ out.fish.D = LCBD.comp(out.comp$D, sqrt.D=TRUE)   # out.comp.D is not Euclidean
+ out.fish.D$beta
+ out.fish.Repl = LCBD.comp(out.comp$repl, sqrt.D=TRUE)   # out.comp$repl is not Euclidean
+ out.fish.Repl$beta
+ out.fish.AbDiff = LCBD.comp(out.comp$rich, sqrt.D=FALSE)   # out.comp$rich is Euclidean
+ out.fish.AbDiff$beta
+ 
+ ### Plot maps of the LCBD indices
+ fish.xy = doubs$xy[-8,]   # Geographic coordinates; site 8 removed because no fish were caught
+ 
+ # Map of LCBD indices for %difference dissimilarity
+ s.value(fish.xy, out.fish.D$LCBD, method="size", symbol = "circle",
+ col = c("white", "brown"), main = "Doubs fish LCBD, %difference D")
+ 
+ # Map of LCBD indices for replacement component of %difference dissimilarity
+ s.value(fish.xy, out.fish.Repl$LCBD, method="size", symbol = "circle",
+ col = c("white", "brown"), main = "Doubs fish replacement LCBD")
+ 
+ # Map of LCBD indices for abundance difference component of %difference dissimilarity
+ s.value(fish.xy, out.fish.AbDiff$LCBD, method="size", symbol = "circle", 
+ col = c("white", "brown"), main = "Doubs fish abundance diff. LCBD")
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati


Attaching package: ‘adegraphics’

The following objects are masked from ‘package:ade4’:

    kplotsepan.coa, s.arrow, s.class, s.corcircle, s.distri, s.image,
    s.label, s.logo, s.match, s.traject, s.value, table.value,
    triangle.class

> 
> ## No test: 
> if(require("ade4", quietly = TRUE) & require("betapart", quietly = TRUE)){
+ ### Example 3
+ ### This example requires packages \code{"betapart"} and \code{"ade4"} for data. 
+ ### For the Baselga-family indices, the same partitioning results are obtained using
+ ### (1) beta.div.comp or (2) beta.pair.abund() of \code{"betapart"} and LCBD.comp()
+ 
+ data(doubs)   # Data available in \code{"ade4"}
+ fish.sp = doubs$fish[-8,]   
+ # Fish data; site 8 is removed because no fish were caught
+ # We use abundance data in this example, not presence-absence data
+ 
+ # Partition into Baselga-family replacement and nestedness components 
+ # using \code{"beta.div.comp"} with the percentage difference index (aka Bray-Curtis)
+ out.comp = beta.div.comp(fish.sp, coef="BS", quant=TRUE)
+ out.comp$part
+ 
+ # Compute the D and component matrices using \code{"beta.pair.abund"}
+ out3 = beta.pair.abund(fish.sp, index.family = "bray")
+ summary(out3)
+ 
+ is.euclid(out3$beta.bray)    # D matrix out3$beta.bray is not Euclidean
+ out3.D = LCBD.comp(out3$beta.bray, sqrt.D=TRUE)
+ out3.D$beta
+ # Compare BDtotal here to BDtotal in out.comp$part (above)
+ 
+ out3.Repl = LCBD.comp(out3$beta.bray.bal, sqrt.D=TRUE)
+ out3.Repl$beta
+ # Compare BDtotal here to RichDiff in out.comp$part (above)
+ 
+ out3.AbDiff = LCBD.comp(out3$beta.bray.gra, sqrt.D=TRUE)
+ out3.AbDiff$beta
+ # Compare BDtotal here to RichDiff/Nes in out.comp$part (above)
+ }
  SStotal   BDtotal 
3.1033015 0.1108322 
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("LCBD.comp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:betapart’, ‘package:adegraphics’, ‘package:ade4’,
  ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("ScotchWhiskey")
> ### * ScotchWhiskey
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ScotchWhiskey
> ### Title: Scotch Whiskey Data Set
> ### Aliases: ScotchWhiskey
> ### Keywords: Scotch Whiskey
> 
> ### ** Examples
> 
> data(ScotchWhiskey)
> lapply(ScotchWhiskey,ncol)
$geo
[1] 6

$colour
NULL

$nose
[1] 12

$body
[1] 8

$palate
[1] 15

$finish
[1] 19

$nbChar
NULL

$listW
NULL

$links.mat
[1] 109

$neighbors
[1] 2

$dist
NULL

> ScotchWhiskey$nbChar
$nose
  [1] 3 2 3 3 3 2 2 5 2 2 2 2 2 4 2 2 4 2 1 2 3 2 3 1 3 1 4 5 4 4 3 4 3 5 5 4 4
 [38] 2 3 2 4 3 4 2 3 3 5 2 2 4 2 4 4 2 3 5 2 5 3 4 3 3 2 6 2 4 3 4 3 6 3 5 5 2
 [75] 3 4 3 4 2 4 2 1 3 2 4 3 4 3 3 4 6 3 4 3 4 1 3 4 3 3 4 4 2 3 3 5 2 3 1

$body
  [1] 2 5 4 1 1 1 1 4 1 1 2 2 4 1 2 2 2 2 3 3 3 2 2 2 2 2 4 1 2 1 3 2 2 5 1 2 3
 [38] 2 3 1 3 4 4 3 4 1 3 2 3 4 2 2 3 4 4 4 2 3 3 3 3 4 2 2 2 4 3 2 3 2 3 3 2 2
 [75] 2 3 2 3 2 2 3 3 3 2 1 2 3 2 2 4 2 2 2 3 1 2 1 4 2 2 2 3 2 2 2 3 3 3 3

$palate
  [1] 2 5 1 3 4 3 3 2 3 3 2 2 2 7 1 5 1 4 4 3 2 2 2 5 5 4 2 2 3 2 8 6 2 4 4 3 3
 [38] 2 3 2 3 2 5 3 3 1 4 3 2 2 4 4 5 5 4 4 4 3 1 4 5 1 4 4 2 4 3 3 4 2 3 1 3 3
 [75] 6 2 4 3 2 4 1 4 2 4 2 3 3 4 4 5 4 4 3 3 1 3 3 3 2 4 4 2 2 5 3 3 2 2 5

$finish
  [1] 4 2 1 1 1 1 3 1 2 2 1 3 3 2 3 2 2 2 1 1 2 3 5 2 1 3 1 1 1 4 2 1 2 2 1 3 1
 [38] 3 2 1 4 3 2 3 3 2 2 4 1 3 2 3 3 2 3 3 2 2 2 3 2 2 2 3 2 1 4 1 2 2 2 2 2 2
 [75] 6 4 2 4 2 2 3 3 2 2 4 3 3 2 1 3 4 3 1 2 2 1 3 5 3 3 3 1 1 2 3 1 1 3 3

> ScotchWhiskey$listW  ## attr(ScotchWhiskey$listW,"class")
Characteristics of weights list object:
Neighbour list object:
Number of regions: 109 
Number of nonzero links: 634 
Percentage nonzero weights: 5.336251 
Average number of links: 5.816514 

Weights style: B 
Weights constants summary:
    n    nn  S0   S1    S2
B 109 11881 634 1268 15568
> names(ScotchWhiskey)
 [1] "geo"       "colour"    "nose"      "body"      "palate"    "finish"   
 [7] "nbChar"    "listW"     "links.mat" "neighbors" "dist"     
> names(ScotchWhiskey$dist)
[1] "nose"   "body"   "palate" "finish"
> 
> plotWhiskey <- function(main) {
+     plot(x=ScotchWhiskey$geo@coords[,1L]/1000,
+          xlab="Eastings (km)",
+          y=ScotchWhiskey$geo@coords[,2L]/1000,
+          ylab="Northings (km)",
+          main=main,
+          type="n",asp=1)
+     apply(
+         ScotchWhiskey$neighbor@data,1L,
+         function(X,coords) {
+             segments(
+                 coords[X[1L],1L]/1000,
+                 coords[X[1L],2L]/1000,
+                 coords[X[2L],1L]/1000,
+                 coords[X[2L],2L]/1000
+             )
+         },
+         coords=ScotchWhiskey$geo@coords
+     )
+     invisible(NULL)
+ }
> 
> plotWhiskey("Scotch whiskey: peat nose")
> cols <- c("blue","orange")
> points(ScotchWhiskey$geo@coords/1000,pch=21L,
+        bg=cols[ScotchWhiskey$nose[,"peat"]+1L])
> legend(x=50,y=1000,legend=c("Has a peat nose","Has no peat nose"),
+        pch=21L,pt.bg=rev(cols))
> 
> plotWhiskey("Scotch whiskey: soft body")
> cols <- c("red","green")
> points(ScotchWhiskey$geo@coords/1000,pch=21L,
+        bg=cols[ScotchWhiskey$body[,"soft"]+1L])
> legend(x=50,y=1000,legend=c("Has a soft body","Has no soft body"),
+        pch=21L,pt.bg=rev(cols))
> 
> plotWhiskey("Scotch whiskey: spicy palate")
> cols <- c("red","green")
> points(ScotchWhiskey$geo@coords/1000,pch=21L,
+        bg=cols[ScotchWhiskey$palate[,"spice"]+1L])
> legend(x=50,y=1000,legend=c("Has a spicy palate","Has no spicy palate"),
+        pch=21L,pt.bg=rev(cols))
> 
> plotWhiskey("Scotch whiskey: sweet finish")
> cols <- c("red","green")
> points(ScotchWhiskey$geo@coords/1000,pch=21L,
+        bg=cols[ScotchWhiskey$finish[,"sweet"]+1L])
> legend(x=50,y=1000,legend=c("Has a sweet finish","Has no sweet finish"),
+        pch=21L,pt.bg=rev(cols))
> 
> ## To visualize (part of) the distance matrices:
> as.matrix(ScotchWhiskey$dist$nose)[1:5,1:5]
          1         2         3         4         5
1 0.0000000 0.6454972 0.5773503 0.7071068 0.5773503
2 0.6454972 0.0000000 0.6454972 0.5000000 0.6454972
3 0.5773503 0.6454972 0.0000000 0.7071068 0.7071068
4 0.7071068 0.5000000 0.7071068 0.0000000 0.5773503
5 0.5773503 0.6454972 0.7071068 0.5773503 0.0000000
> as.matrix(ScotchWhiskey$dist$body)[1:5,1:5]
          1         2         3         4         5
1 0.0000000 0.6123724 0.7071068 0.6123724 0.3535534
2 0.6123724 0.0000000 0.7905694 0.7071068 0.7071068
3 0.7071068 0.7905694 0.0000000 0.6123724 0.7905694
4 0.6123724 0.7071068 0.6123724 0.0000000 0.5000000
5 0.3535534 0.7071068 0.7905694 0.5000000 0.0000000
> as.matrix(ScotchWhiskey$dist$palate)[1:5,1:5]
          1         2         3         4         5
1 0.0000000 0.5773503 0.4472136 0.5773503 0.6324555
2 0.5773503 0.0000000 0.5163978 0.6324555 0.5773503
3 0.4472136 0.5163978 0.0000000 0.3651484 0.4472136
4 0.5773503 0.6324555 0.3651484 0.0000000 0.4472136
5 0.6324555 0.5773503 0.4472136 0.4472136 0.0000000
> as.matrix(ScotchWhiskey$dist$finish)[1:5,1:5]
          1         2         3         4         5
1 0.0000000 0.5619515 0.5129892 0.5129892 0.3973597
2 0.5619515 0.0000000 0.3973597 0.3973597 0.3973597
3 0.5129892 0.3973597 0.0000000 0.3244428 0.3244428
4 0.5129892 0.3973597 0.3244428 0.0000000 0.3244428
5 0.3973597 0.3973597 0.3244428 0.3244428 0.0000000
> 
> ## The data tables:
> ScotchWhiskey$colour
  [1] yellow  red     sherry  p.gold  p.gold  v.pale  wyne    p.gold  amber  
 [10] f.gold  f.amber gold    amber   amber   yellow  p.gold  o.gold  o.gold 
 [19] pale    gold    wyne    f.gold  pale    amber   p.gold  f.gold  gold   
 [28] f.gold  gold    f.amber f.amber gold    pale    f.gold  gold    pale   
 [37] amber   v.pale  gold    f.gold  gold    gold    amber   f.gold  gold   
 [46] bronze  wyne    f.gold  gold    f.gold  f.gold  bronze  gold    p.gold 
 [55] f.gold  f.gold  gold    p.gold  p.gold  f.gold  f.gold  f.gold  gold   
 [64] wyne    wyne    f.gold  bronze  amber   f.gold  gold    f.gold  gold   
 [73] gold    bronze  p.gold  gold    wyne    p.amber f.gold  f.gold  wyne   
 [82] f.gold  amber   f.gold  amber   red     p.gold  p.amber f.gold  amber  
 [91] amber   amber   amber   red     amber   f.amber bronze  gold    gold   
[100] amber   red     p.amber wyne    p.amber f.gold  f.gold  f.gold  f.gold 
[109] gold   
14 Levels: amber bronze f.amber f.gold gold o.gold p.amber p.gold pale ... yellow
> head(ScotchWhiskey$nose)
     aroma  peat sweet light fresh   dry fruit grass   sea sherry spicy  rich
[1,]  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  FALSE FALSE FALSE
[2,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  FALSE FALSE  TRUE
[3,] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  FALSE FALSE FALSE
[4,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE   TRUE FALSE FALSE
[5,] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  FALSE FALSE FALSE
[6,]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  FALSE FALSE FALSE
> head(ScotchWhiskey$body)
      soft   med  full round smooth light  firm  oily
[1,]  TRUE  TRUE FALSE FALSE  FALSE FALSE FALSE FALSE
[2,]  TRUE  TRUE  TRUE  TRUE   TRUE FALSE FALSE FALSE
[3,] FALSE  TRUE  TRUE FALSE  FALSE  TRUE  TRUE FALSE
[4,] FALSE FALSE  TRUE FALSE  FALSE FALSE FALSE FALSE
[5,]  TRUE FALSE FALSE FALSE  FALSE FALSE FALSE FALSE
[6,] FALSE FALSE FALSE FALSE  FALSE FALSE  TRUE FALSE
> head(ScotchWhiskey$palate)
      full   dry sherry   big light smooth clean fruit grass smoke sweet spice
[1,] FALSE FALSE   TRUE FALSE FALSE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[2,]  TRUE FALSE   TRUE FALSE FALSE  FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE
[3,] FALSE FALSE  FALSE FALSE FALSE  FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
[4,] FALSE FALSE  FALSE  TRUE FALSE  FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
[5,] FALSE FALSE  FALSE FALSE  TRUE  FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE
[6,] FALSE FALSE  FALSE FALSE  TRUE  FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
       oil  salt arome
[1,]  TRUE FALSE FALSE
[2,] FALSE FALSE FALSE
[3,] FALSE FALSE FALSE
[4,] FALSE FALSE FALSE
[5,] FALSE FALSE FALSE
[6,] FALSE FALSE FALSE
> head(ScotchWhiskey$finish)
      full   dry  warm   big light smooth clean fruit grass smoke sweet spice
[1,]  TRUE  TRUE FALSE FALSE FALSE  FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
[2,] FALSE FALSE FALSE FALSE FALSE  FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
[3,] FALSE FALSE FALSE FALSE FALSE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[4,] FALSE FALSE FALSE  TRUE FALSE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[5,] FALSE FALSE FALSE FALSE FALSE  FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
[6,] FALSE  TRUE FALSE FALSE FALSE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE
       oil  salt arome  ling  long  very quick
[1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[2,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
[3,] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
[4,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[5,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[6,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ScotchWhiskey", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("TBI")
> ### * TBI
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: TBI
> ### Title: TBI: Difference between multivariate observations at T1 and T2
> ### Aliases: TBI
> 
> ### ** Examples
> 
> if(require("vegan", quietly = TRUE)) {
+ 
+ ## Example 1 -
+ 
+ ## Invertebrate communities subjected to insecticide treatment.
+ 
+ ## As an example in their paper on Principal Response Curves (PRC method), van den
+ ## Brink & ter Braak (1999) used observations on the abundances of 178 invertebrate
+ ## species (macroinvertebrates and zooplankton) subjected to treatments in 12 mesocosms by
+ ## the insecticide chlorpyrifos. The mesocosms were sampled at 11 occasions. The data,
+ ## available in the {vegan} package, are log-transformed species abundances, ytranformed =
+ ## log(10*y+1).
+ 
+ ## The data of survey #4 will be compared to those of survey #11 in this example.
+ ## Survey #4 was carried out one week after the insecticide treatment, whereas the fauna
+ ## of the mesocosms was considered by the authors to have fully recovered from the
+ ## insecticide treatment at survey #11.
+ 
+ data(pyrifos)
+ 
+ ## The mesocosms had originally been attributed at random to the treatments. However,
+ ## to facilitate presentation of the results, they will be listed here in order of
+ ## increased insecticide doses: {0, 0, 0, 0, 0.1, 0.1, 0.9, 0.9, 6, 6, 44, 44} micro g/L.
+ 
+ ## Select the 12 data rows of surveys 4 and 11 from the data file and reorder them
+ 
+ ord4 = c(38,39,41,47,37,44,40,46,43,48,42,45)
+ 
+ ord11 = c(122,123,125,131,121,128,124,130,127,132,126,129)
+ 
+ ## Run the TBI function
+ 
+ res1 <- TBI(pyrifos[ord4,], pyrifos[ord11,], method = "%diff", nperm = 0, test.t.perm = FALSE)
+ 
+ res1$BCD.mat
+ 
+ ## Example 2 -
+ 
+ ## This example uses the mite data available in vegan. Let us pretend that sites 1-20
+ ## represent T1 and sites 21-40 represent T2.
+ 
+ 
+ data(mite)
+ 
+ # Run the TBI function
+ 
+ res2 <- TBI(mite[1:20,], mite[21:40,], method = "%diff", nperm = 0, test.t.perm = FALSE)
+ 
+ summary(res2)
+ 
+ res2$BCD.mat
+ 
+ }
This is vegan 2.6-6.1
        B/(2A+B+C) C/(2A+B+C) D=(B+C)/(2A+B+C) Change
Site.1   0.3618677 0.27237354        0.6342412    -  
Site.2   0.4454545 0.22727273        0.6727273    -  
Site.3   0.5505618 0.15730337        0.7078652    -  
Site.4   0.5928962 0.03005464        0.6229508    -  
Site.5   0.3167702 0.08074534        0.3975155    -  
Site.6   0.3373860 0.06686930        0.4042553    -  
Site.7   0.1582090 0.19104478        0.3492537    +  
Site.8   0.2784810 0.21518987        0.4936709    -  
Site.9   0.2991453 0.24786325        0.5470085    -  
Site.10  0.4274809 0.16030534        0.5877863    -  
Site.11  0.4624277 0.21387283        0.6763006    -  
Site.12  0.4869281 0.09477124        0.5816993    -  
Site.13  0.4153355 0.28434505        0.6996805    -  
Site.14  0.3131749 0.15118790        0.4643629    -  
Site.15  0.3507109 0.40284360        0.7535545    +  
Site.16  0.2000000 0.35652174        0.5565217    +  
Site.17  0.2052402 0.41921397        0.6244541    +  
Site.18  0.2833876 0.51465798        0.7980456    +  
Site.19  0.3443396 0.23113208        0.5754717    -  
Site.20  0.4545455 0.37536657        0.8299120    -  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("TBI", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("Tiahura")
> ### * Tiahura
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Tiahura
> ### Title: Tiahura Transect Fish Data Set
> ### Aliases: Tiahura
> ### Keywords: Tiahura
> 
> ### ** Examples
> 
> data(Tiahura)
> 
> ## Compute dissimilary matrix from Jaccard's similarity coefficient:
> tiah.jac <- dist.ldc(Tiahura$fish,method = "jaccard")
Info -- D is Euclidean because the function outputs D[jk] = sqrt(1-S[jk])
> 
> ## Constrained clustering of the fish species:
> tiah.chclust <- constr.hclust(tiah.jac, coords=Tiahura$habitat[,"distance"],
+                               chron=TRUE)
> 
> ## Plotting the results
> par(mfrow=c(3,1))
> 
> ## First graph: constrained clusters
> par(mar=c(3,6.5,2,2))
> dst <- Tiahura$habitat[,"distance"]
> plot(NA, xlim=range(dst), ylim=c(0.5,5.5), yaxt="n",
+      ylab="Partitions\n\n", xlab="")
> parts <- c(2,3,5,7,12)
> cols <- c("turquoise", "orange", "chartreuse", "aquamarine", "blue",
+           "violet", "pink", "cyan", "green", "red", "cornsilk", "purple")
> for(i in 1L:length(parts)) {
+   tiah.chclust$coords[,"y"] <- i
+   plot(tiah.chclust, parts[i], link=TRUE, lwd=3, hybrids="none",
+        lwd.pt=0.5, cex=3, pch=21, plot=FALSE,
+        col=cols[round(seq(1,length(cols), length.out=parts[i]))])
+ }
> axis(2, at=1:length(parts), labels=paste(parts,"groups"), las=1)
> 
> ## Second graph: transect profile
> par(mar=c(4,6.5,1,2))
> plot(x=dst, y=Tiahura$habitat[,"depth"],
+      ylim=c(max(range(Tiahura$habitat[,"depth"])),-300),
+      las=1, ylab="Depth\n(cm)\n", xlab="", type="l", lwd=2)
> for(i in 1:nrow(Tiahura$reef)) {
+   abline(v=Tiahura$reef[i,2], lty=3)
+   abline(v=Tiahura$reef[i,3], lty=3)
+   if((Tiahura$reef[i,3] - Tiahura$reef[i,2])<100) {
+     text(x=(Tiahura$reef[i,2] + Tiahura$reef[i,3])/2, y=2350,
+          labels=toupper(Tiahura$reef[i,1]),srt=90,adj=0)
+   } else {
+     text(x=(Tiahura$reef[i,2] + Tiahura$reef[i,3])/2, y=-150,
+          labels=toupper(Tiahura$reef[i,1]))
+   }
+ }
> 
> ## Third graph: bottom composition
> par(mar=c(5,6.5,0,2))
> plot(NA,xlim=range(dst), ylim=c(0,1), las=1,
+      ylab="Bottom composition\n(proportions)\n", xlab="Distance (m)")
> bot <- cbind(0, Tiahura$habitat[,3:10])
> for(i in 2:9) bot[,i] <- bot[,i] + bot[,i-1]
> cols <- c("", "grey75", "brown", "grey25", "green", "purple",
+           "lightgreen", "yellow", "white")
> for(i in 2:9)
+   polygon(x=c(dst, rev(dst)),y=c(bot[,i], rev(bot[,i-1]))/50,
+           col=cols[i])
> text(x=c(44, 365, 707, 538, 957, 111, 965),
+      y=c(0.05, 0.47, 0.37, 0.58, 0.42, 0.80, 0.88),
+      labels=colnames(bot)[2:8], xpd=TRUE)
> 
> ## Species presence graph set:
> plot_slice <- function(sl,split) {
+   size <- ceiling(length(Tiahura$species)/split)
+   sp_slice <- size*(sl - 1L) + (1L:size)
+   image(z=t(as.matrix(Tiahura$fish[,sp_slice])),y=1:nrow(Tiahura$fish),
+         x=1:length(sp_slice),zlim=c(0,1),col=c("white","black"),axes=FALSE,
+         ylab="",xlab="")
+   axis(1L,at=1:length(sp_slice),labels=Tiahura$species[sp_slice],las=2L)
+   axis(2L,at=1:nrow(Tiahura$fish),label=rownames(Tiahura$fish),las=1L)
+   invisible(NULL)
+ }
> 
> par(mar=c(15,5,2,2))
> plot_slice(1L,5L)
> ## plot_slice(2L,5L)
> ## plot_slice(3L,5L)
> ## plot_slice(4L,5L)
> ## plot_slice(5L,5L)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Tiahura", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("WRperiodogram")
> ### * WRperiodogram
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: WRperiodogram
> ### Title: Whittaker-Robinson periodogram
> ### Aliases: WRperiodogram plot.WRperio
> ### Keywords: multivariate
> 
> ### ** Examples
> 
>  
> ### 1. Numerical example from Subsection 12.4.1 of Legendre and Legendre (2012)
> 
> test.vec <- c(2,2,4,7,10,5,2,5,8,4,1,2,5,9,6,3)
> 
> # Periodogram with permutation tests of significance
> res <- WRperiodogram(test.vec)
> plot(res) # Plot the periodogram
> 
> #####
> 
> ### 2. Simulated data
> 
> # Generate a data series with periodic component using Legand's (1958) equation.
> # Ref. Legendre and Legendre (2012, eq. 12.8, p. 753)
> # x = time points, T = generated period, c = shift of curve, left (+) or right (-)
> 
> periodic.component <- function(x,T,c){cos((2*pi/T)*(x+c))}
> 
> n <- 500   # corresponds to 125 days with 4 observations per day
> # Generate a lunar cycle, 29.5 days (T=118)
> moon <- periodic.component(1:n, 118, 59)
> # Generate a circadian cycle (T=4)
> daily <- periodic.component(1:n, 4, 0)
> # Generate an approximate tidal cycle (T=2)
> # A real tidal signal would have a period of 12.42 h
> tide <- periodic.component(1:n, 2, 0)
> 
> # Periodogram of the lunar component only 
> res.moon.250 <- WRperiodogram(moon, nperm=0)  # T1=2, T2=n/2=250; no test
> res.moon.130 <- WRperiodogram(moon, T2=130, nperm=499)
> oldpar <- par(mfrow=c(1,2))
> # Plot 2 moon cycles, n = 118*2 = 236 points
> plot(moon[1:236], xlab="One time unit = 6 hours") 
> plot(res.moon.130, prog=1) # Plot the periodogram
> 
> #####
> 
> # Add the daily and tidal components, plus a random normal error. With daily (T=4) and 
> # tide (T=2), period 4 and its harmonics should have a higher W statistic than period 2
> var1 <- daily + tide + rnorm(n, 0, 0.5)
> # Plot a portion (40 points) of the data series
> # Two periodic components identifiable. Tide (T=2) reinforces the daily signal (T=4)
> par(mfrow=c(1,2))
> plot(var1[1:40], pch=".", cex=1, xlab="One time unit = 6 hours")
> lines(var1[1:40])
> # Periodogram of 'var'
> res.var1 <- WRperiodogram(var1, T2=40, nperm=499)
> plot(res.var1, prog=3, line.col="blue") # Plot the periodogram
> # The progressive correction for multiple tests (prog=3) was used in the periodogram.
> 
> #####
> 
> # Add the three components, plus a random normal error term
> # to show that the WRperiodogram can test several periodic components at the same time.
> # (5*moon) makes the lunar periods stronger than the daily and tidal periods
> var2 <- 5*moon + daily + tide + rnorm(n, 0, 0.5)
> # Plot a portion (150 points) of the data series
> # The three periodic components are identifiable
> par(mfrow=c(1,2))
> plot(var2[1:150], pch=".", cex=1, xlab="One time unit = 6 hours")
> lines(var2[1:150])
> 
> # Periodogram of 'var'
> res.var2 <- WRperiodogram(var2, T2=130, nperm=499)
> plot(res.var2, prog=1, line.col="blue") # Plot the periodogram
> # Find the position of the maximum W statistic value in this periodogram
> (which(res.var2[,2] == max(res.var2[,2])) -1)
[1] 118
> # "-1" correction at the end of the previous line: the first computed period is T=2, 
> # so period #118 is on line #117 of file res.var2
> 
> #####
> 
> # Illustration that the WR periodogram can handle missing values:
> # Replace 10% of the 500 data by NA
> select <- sort(sample(1:500)[1:50])
> var.na <- var2
> var.na[select] <- NA
> res.var.na <- WRperiodogram(var.na, T2=130, nperm=499)
> # Plot the periodogram with no correction for multiple tests
> plot(res.var.na, prog=1)
> # Plot periodogram again with progressive correction for multiple tests
> plot(res.var.na, prog=3) 
> 
> #####
> 
> ### 3. Data used in the examples of the documentation file of function afc() of {stats}
> # Data file "ldeaths"; time series, 6 years x 12 months of deaths in UK hospitals
> # First, examine the data file ldeaths. Then:
> ld.res.perio <- WRperiodogram(ldeaths, nperm=499)
> # Plot the periodogram with two types of corrections for multiple tests
> par(mfrow=c(1,2))
> plot(ld.res.perio, prog=1) # No correction for multiple testing
> plot(ld.res.perio, prog=3) # Progressive correction for multiple tests
> # The yearly cycle and harmonics are significant
> # Compare the results of afc() to those of WRperiodogram above
> acf(ldeaths)   # lag=1.0 is one year; see ?acf
> par(oldpar)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("WRperiodogram", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("aem")
> ### * aem
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aem
> ### Title: Construct asymmetric eigenvector maps (AEM)
> ### Aliases: aem
> ### Keywords: spatial
> 
> ### ** Examples
> 
> # Construction of object of class nb (spdep)
> if(require("spdep", quietly = TRUE)){
+ nb <- cell2nb(5,5,"queen")
+ 
+ # Create fictitious geographical coordinates 
+ xy <- cbind(1:25,expand.grid(1:5,1:5))
+ 
+ # Build binary site-by-link matrix
+ bin.mat <- aem.build.binary(nb,xy)
+ 
+ # Construct AEM eigenfunctions from an object of class aem.build.binary
+ res <- aem(aem.build.binary=bin.mat,rm.link0=FALSE)
+ res$values
+ 
+ # Illustrate 4 AEM eigenfunctions using bubble plots
+ opal <- palette()
+ palette(c("black","white"))
+ oldpar <- par(mfrow=c(2,2))
+ symbols(x=xy[,2:3], circles=abs(res$vectors[,1]), inches=FALSE, asp=1,
+  fg=ifelse(sign(-res$vectors[,1])+1>0,1,0), 
+  bg=ifelse(sign(res$vectors[,1])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 1")
+ symbols(x=xy[,2:3], circles=abs(res$vectors[,2]), inches=FALSE, 
+ asp=1, fg=ifelse(sign(-res$vectors[,2])+1>0,1,0),
+  bg=ifelse(sign(res$vectors[,2])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 2")
+ symbols(x=xy[,2:3], circles=abs(res$vectors[,3]), inches=FALSE, 
+ asp=1, fg=ifelse(sign(-res$vectors[,3])+1>0,1,0), 
+ bg=ifelse(sign(res$vectors[,3])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 3")
+ symbols(x=xy[,2:3], circles=abs(res$vectors[,4]), inches=FALSE, asp=1,
+  fg=ifelse(sign(-res$vectors[,4])+1>0,1,0), 
+  bg=ifelse(sign(res$vectors[,4])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 4")
+ 
+ # Construct AEM eigenfunctions using only a site-by-link matrix
+ res2 <- aem(binary.mat=bin.mat[[1]])
+ res2$values
+ 
+ # Illustrate 4 AEM eigenfunctions using bubble plots
+ par(mfrow=c(2,2))
+ symbols(x=xy[,2:3], circles=abs(res2$vectors[,1]), inches=FALSE, 
+ asp=1, fg=ifelse(sign(-res2$vectors[,1])+1>0,1,0), 
+ bg=ifelse(sign(res2$vectors[,1])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 1")
+ symbols(x=xy[,2:3], circles=abs(res2$vectors[,2]), inches=FALSE,
+ asp=1, fg=ifelse(sign(-res2$vectors[,2])+1>0,1,0), 
+ bg=ifelse(sign(res2$vectors[,2])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 2")
+ symbols(x=xy[,2:3], circles=abs(res2$vectors[,3]), inches=FALSE,
+ asp=1, fg=ifelse(sign(-res2$vectors[,3])+1>0,1,0), 
+ bg=ifelse(sign(res2$vectors[,3])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 3")
+ symbols(x=xy[,2:3], circles=abs(res2$vectors[,4]), inches=FALSE,asp=1,
+  fg=ifelse(sign(-res2$vectors[,4])+1>0,1,0), 
+  bg=ifelse(sign(res2$vectors[,4])+1>0,1,0), xlab="x", ylab="y")
+ title("AEM 4")
+ 
+ palette(opal)
+ par(oldpar)
+ 
+ # Construct AEM eigenfunctions with a function of the distance
+ # as weights to put on the links
+ 
+ # Construction of object of class nb (spdep)
+ nb<-cell2nb(5,5,"queen")
+ 
+ # Create fictitious geographical coordinates
+ xy <- cbind(1:25,expand.grid(1:5,1:5))
+ 
+ # Build binary site-by-link matrix
+ bin.mat <- aem.build.binary(nb,xy)
+ 
+ # Construct a matrix of distances
+ long.lien.mat<-as.matrix(dist(xy))
+ 
+ # Extract the edges, remove the ones directly linked to site 0
+ lien.b<-bin.mat$edges[-1:-5,]
+ 
+ # Construct a vector giving the length of each edge
+ long.lien<-vector(length=nrow(lien.b))
+ 
+ for(i in 1:nrow(lien.b)){
+ 	long.lien[i]<-long.lien.mat[lien.b[i,1],lien.b[i,2]]
+ }
+ 
+ # Construct a vector of weights based on distance
+ weight.vec<-1-(long.lien/max(long.lien))^2
+ 
+ # Construct AEM eigenfunctions from an object of class aem.build.binary
+ res <- aem(aem.build.binary=bin.mat,weight=weight.vec,rm.link0=TRUE)
+ res
+ 
+ # Computing Moran's I for AEMs
+ 
+ # Building AEMs
+ xy <- cbind(1:25,expand.grid(1:5,1:5))
+ Wdist <- 1/as.matrix(dist(xy[,2:3]))
+ 
+ nb <- cell2nb(5,5,"queen")
+ bin.mat <- aem.build.binary(nb,xy)
+ linkBase <- bin.mat[[2]]
+ link <- linkBase[-which(linkBase[,1] == 0),]
+ weight <- numeric()
+ 
+ for(i in 1:nrow(link)){
+    weight[i] <- Wdist[link[i,1],link[i,2]]
+ }
+ 
+ AEM <- aem(bin.mat, weight = weight, rm.link0 = TRUE)
+ 
+ # Constructing asymmetric matrix
+ matasym <- matrix(0,ncol=25, nrow=25)
+ 
+ for(i in 1:nrow(link)){
+     matasym[link[i,1],link[i,2]]<- weight[i]
+ }
+ 
+ # Build a listw object from the asymmetric matrix
+ listwAsym <-  mat2listw(matasym, style = "B", zero.policy = TRUE)
+ 
+ # Calculate Moran's I for AEM
+ MoranIAEM <- moran.randtest(AEM$vectors, listwAsym)
+ 
+ }
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aem", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("aem.build.binary")
> ### * aem.build.binary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aem.build.binary
> ### Title: Construct a site-by-edge binary matrix
> ### Aliases: aem.build.binary
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> ### Create an object of class nb (spdep)
> if(require("spdep", quietly = TRUE)){
+ nb<-cell2nb(5,5,"queen")
+ 
+ ### Create fictitious geographical coordinates 
+ xy <- cbind(1:25,expand.grid(1:5,1:5))
+ 
+ ### Build a binary site-by-link matrix; remove the site which have identical Y coordinate
+ ### (by default argument: rm.same.y = TRUE)
+ bin.mat <- aem.build.binary(nb,xy)
+ str(bin.mat)
+ 
+ ### Build a binary site-by-link matrix using the argument link: remove the site which
+ ### have identical Y coordinate (by default argument: rm.same.y = TRUE)
+ edges<-expand.grid(1,2:25)
+ bin.mat <- aem.build.binary(coords=xy,link=edges)
+ str(bin.mat)
+ 
+ ### Build a binary site-by-link matrix, making the process affect the points at 
+ ### an angle of 45 degrees
+ bin.mat.45 <- aem.build.binary(nb,xy, rot.angle=45)
+ str(bin.mat.45)
+ 
+ ### Build a binary site-by-link matrix, making the process affect the points at
+ ### an angle of pi/3 radians
+ bin.mat.pi3 <- aem.build.binary(nb,xy,unit.angle="radians", rot.angle=pi/3)
+ str(bin.mat.pi3)
+ }
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
List of 2
 $ se.mat: int [1:25, 1:57] 1 0 0 0 0 1 1 0 0 0 ...
 $ edges : num [1:57, 1:2] 0 0 0 0 0 1 1 2 2 2 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:57] "" "" "" "" ...
  .. ..$ : chr [1:2] "from" "to"
List of 2
 $ se.mat: int [1:25, 1:25] 1 0 0 0 0 1 1 1 1 1 ...
 $ edges : num [1:25, 1:2] 0 0 0 0 0 1 1 1 1 1 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:25] "" "" "" "" ...
  .. ..$ : chr [1:2] "from" "to"
List of 2
 $ se.mat: int [1:25, 1:57] 1 1 1 1 1 1 1 1 1 1 ...
 $ edges : num [1:57, 1:2] 0 1 1 1 2 2 2 3 3 3 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:57] "" "1" "2" "3" ...
  .. ..$ : chr [1:2] "from" "to"
List of 2
 $ se.mat: int [1:25, 1:73] 1 1 1 1 1 1 1 1 1 1 ...
 $ edges : num [1:73, 1:2] 0 1 1 1 2 6 2 2 3 7 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:73] "" "1" "2" "3" ...
  .. ..$ : chr [1:2] "from" "to"
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aem.build.binary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("aem.time")
> ### * aem.time
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aem.time
> ### Title: AEM for time series
> ### Aliases: aem.time
> ### Keywords: multivariate spatial
> 
> ### ** Examples
> 
> 
> # Time series containing 20 equispaced observations
> out <- aem.time(20, moran = TRUE)
> 
> # Time series containing 20 observations with unequal spacing
> # Generate (n-1) random interpoint distances
> distances <- runif(19,1,5)
> 
> # Compute weights representing the ease of communication among points
> w <- 1/(distances/max(distances))
> 
> # Compute the AEM eigenfunctions
> out <- aem.time(20, w = w, moran = TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aem.time", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aem.weight.edges")
> ### * aem.weight.edges
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aem.weight.edges
> ### Title: Weight edges when constructing AEM variables
> ### Aliases: aem.weight.edges aem.weight.time
> ### Keywords: spatial ts
> 
> ### ** Examples
> 
> 
> ### Time serie example
> ### Example - 12 dates (days from January 1st of year 1) 
> ### in a 6-year study starting September 5, 2000
> if(require("spdep", quietly = TRUE)){
+ dates <- as.Date(c(129,269,500,631,864,976,1228,1352,1606,1730,1957,2087),origin="2000/1/1")
+ autocor.limit <- 522  # Limit of autcorrelation in the correlogram
+ 
+ ### Using aem.weight.time()
+ (wtime <- aem.weight.time(dates, alpha=2, max.d=autocor.limit))
+ ### Using aem.weight.edges()
+ n <- length(dates)
+ nb <- cell2nb(1, n)
+ xy.dates <- cbind(1:n, rep(1, n), dates)
+ (wtime <- aem.weight.edges(nb, xy.dates, alpha=2, max.d=autocor.limit))
+ 
+ n <- length(dates)
+ nb <- cell2nb(1, n)
+ xy.dates <- cbind(1:n, dates, rep(1, n)) ## Note the inversion of 'dates' and 'rep(1,n)'
+ wtime <- aem.weight.edges(nb, xy.dates, alpha=2, 
+ max.d=autocor.limit,rot.angle=90) # Note that 'rot.angle=90' was used
+ 
+ ### Spatial example using default d.max (notice the warning)
+ ###########################################################################
+ nb<-cell2nb(5,5,"queen")
+ xy <- cbind(1:25,expand.grid(1:5,1:5))
+ (wspace <- aem.weight.edges(nb,xy))
+ }
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
[1] "The default value for 'max.d' was used. The weights may not be optimum"
 [1] 0.875 0.750 0.750 0.875 0.750 0.750 0.875 0.750 0.750 0.875 0.750 0.750
[13] 0.875 0.875 0.750 0.750 0.875 0.750 0.750 0.875 0.750 0.750 0.875 0.750
[25] 0.750 0.875 0.875 0.750 0.750 0.875 0.750 0.750 0.875 0.750 0.750 0.875
[37] 0.750 0.750 0.875 0.875 0.750 0.750 0.875 0.750 0.750 0.875 0.750 0.750
[49] 0.875 0.750 0.750 0.875
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aem.weight.edges", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("beta.div")
> ### * beta.div
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: beta.div
> ### Title: Beta diversity computed as Var(Y)
> ### Aliases: beta.div
> 
> ### ** Examples
> 
> 
> if(require("vegan", quietly = TRUE) & require("adegraphics", quietly = TRUE)){
+ data(mite)
+ res = beta.div(mite, "hellinger", nperm=999)
+ 
+ # Plot a map of the LCBD indices using the Cartesian coordinates
+ data(mite.xy)
+ s.value(mite.xy, res$LCBD, symbol = "circle", col = c("white", "brown"), main="Map of mite LCBD")
+ 
+ ### Example using the mite abundance data and the percentage difference dissimilarity
+ res = beta.div(mite, "percentdiff", nperm=999, clock=TRUE)
+ 
+ # Plot a map of the LCBD indices
+ signif = which(res$p.LCBD <= 0.05)	# Which are the significant LCBD indices?
+ nonsignif = which(res$p.LCBD > 0.05)	# Which are the non-significant LCBD indices?
+ g1 <- s.value(mite.xy[signif,], res$LCBD[signif], ppoint.alpha = 0.5, plegend.drawKey = FALSE,
+  symbol = "circle", col = c("white", "red"), main="Map of mite LCBD (red = significant indices)")
+ g2 <- s.value(mite.xy[nonsignif,], res$LCBD[nonsignif], ppoint.alpha = 0.5,
+ symbol = "circle", col = c("white", "blue"))
+ g2+g1
+ }
This is vegan 2.6-6.1
Time for computation = 1.507000  sec
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("beta.div", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:adegraphics’, ‘package:vegan’, ‘package:lattice’,
  ‘package:permute’

> nameEx("beta.div.comp")
> ### * beta.div.comp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: beta.div.comp
> ### Title: Decompose D in replacement and richness difference components
> ### Aliases: beta.div.comp
> 
> ### ** Examples
> 
> 
> if(require(ade4, quietly = TRUE)){
+ data(doubs)
+ fish.sp = doubs$fish[-8,]   # Fish data; site 8 is removed because no fish were caught
+ 
+ # Compute and partition a matrix of Jaccard indices (presence-absence data)
+ out1 = beta.div.comp(fish.sp, coef="J", quant=FALSE)
+ out1$part
+ 
+ # Compute and partition a matrix of percentage difference indices
+ # (quantitative form of Sorensen index)
+ out2 = beta.div.comp(fish.sp, coef="S", quant=TRUE)
+ out2$part
+ # In paragraph Value, see the description of the 5 elements of vector part. 
+ # Is the fish beta diversity dominated by replacement or richness/abundance difference?
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

        BDtotal            Repl         RichDif    Repl/BDtotal RichDif/BDtotal 
      0.3237960       0.1203572       0.2034388       0.3717068       0.6282932 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("beta.div.comp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ade4’

> nameEx("chooseCN")
> ### * chooseCN
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: chooseCN
> ### Title: Function to choose a connection network
> ### Aliases: chooseCN
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE)){
+ data(mafragh)
+ 
+ oldpar <- par(mfrow=c(2,2))
+ cn1 <- chooseCN(mafragh$xy,ask=FALSE,type=1)
+ cn2 <- chooseCN(mafragh$xy,ask=FALSE,type=2)
+ cn3 <- chooseCN(mafragh$xy,ask=FALSE,type=3)
+ cn4 <- chooseCN(mafragh$xy,ask=FALSE,type=4)
+ par(oldpar)
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("chooseCN", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:ade4’

> nameEx("constr.hclust")
> ### * constr.hclust
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: constr.hclust
> ### Title: Space- And Time-Constrained Clustering
> ### Aliases: constr.hclust
> 
> ### ** Examples
> 
> 
> ## First example: Artificial map data from Legendre & Legendre
> ##                (2012, Fig. 13.26): n = 16
> 
> dat <- c(41,42,25,38,50,30,41,43,43,41,30,50,38,25,42,41)
> coord.dat <- matrix(c(1,3,5,7,2,4,6,8,1,3,5,7,2,4,6,8,
+                       4.4,4.4,4.4,4.4,3.3,3.3,3.3,3.3,
+                       2.2,2.2,2.2,2.2,1.1,1.1,1.1,1.1),16,2)
> 
> ## Obtaining a list of neighbours:
> library(spdep)
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
> listW <- nb2listw(tri2nb(coord.dat), style="B")
> links.mat.dat <- listw2mat(listW)
> neighbors <- listw2sn(listW)[,1:2]
> 
> ## Calculating the (Euclidean) distance between points:
> D.dat <- dist(dat)
> 
> ## Display the points:
> plot(coord.dat, type='n',asp=1)
> title("Delaunay triangulation")
> text(coord.dat, labels=as.character(as.matrix(dat)), pos=3)
> for(i in 1:nrow(neighbors))
+     lines(rbind(coord.dat[neighbors[i,1],],
+           coord.dat[neighbors[i,2],]))
> 
> ## Unconstrained clustring by hclust:
> grpWD2_hclust <- hclust(D.dat, method="ward.D2")
> plot(grpWD2_hclust, hang=-1)
> 
> ## Clustering without a contiguity constraint;
> ## the result is represented as a dendrogram:
> grpWD2_constr_hclust <- constr.hclust(D.dat, method="ward.D2")
> plot(grpWD2_constr_hclust, hang=-1)
> 
> ## Clustering with a contiguity constraint described by a list of
> ## links:
> grpWD2cst_constr_hclust <-
+     constr.hclust(
+         D.dat, method="ward.D2",
+         neighbors, coord.dat)
> 
> ## To visualize using hclust's plotting method:
> ## stats:::plot.hclust(grpWD2cst_constr_hclust, hang=-1)
> 
> ## Plot the results on a map with k=3 clusters:
> plot(grpWD2cst_constr_hclust, k=3, links=TRUE, las=1, xlab="Eastings",
+      ylab="Northings", cex=3, lwd=3)
> 
> ## Generic functions from hclust can be used, for instance to obtain
> ## a list of members of each cluster:
> cutree(grpWD2cst_constr_hclust, k=3)
 [1] 1 1 2 3 1 2 3 3 1 1 2 3 1 2 3 3
> 
> ## Now with k=5 clusters:
> plot(grpWD2cst_constr_hclust, k=5, links=TRUE, las=1, xlab="Eastings",
+      ylab="Northings", cex=3, lwd=3)
> cutree(grpWD2cst_constr_hclust, k=5)
 [1] 1 1 2 3 4 2 3 3 1 1 2 5 1 2 3 3
> 
> ## End of the artificial map example
> 
> 
> ## Second example: Scotch Whiskey distilleries clustered using tasting
> ## scores (nose, body, palate, finish, and the four distances combined)
> ## constrained with respect to the distillery locations in Scotland.
> 
> ## Documentation file about the Scotch Whiskey data: ?ScotchWhiskey
> 
> data(ScotchWhiskey)
> 
> ## Cluster analyses for the nose, body, palate, and finish D
> ## matrices:
> 
> grpWD2cst_ScotchWhiskey <-
+     lapply(
+         ScotchWhiskey$dist,    ## A list of distance matrices
+         constr.hclust,         ## The function called by function lapply
+         links=ScotchWhiskey$neighbors@data,         ## The list of links
+         coords=ScotchWhiskey$geo@coords/1000
+     )
> 
> ## The four D matrices (nose, body, palate, finish), represented as
> ## vectors in the ScotchWiskey data file, are combined as follows to
> ## produce a single distance matrix integrating all four types of
> ## tastes:
> 
> Dmat <- ScotchWhiskey$dist
> ScotchWhiskey[["norm"]] <-
+     sqrt(Dmat$nose^2 + Dmat$body^2 + Dmat$palate^2 + Dmat$finish^2)
> 
> ## This example shows how to apply const.clust to a single D matrix when
> ## the data file contains several matrices.
> 
> grpWD2cst_ScotchWhiskey[["norm"]] <-
+     constr.hclust(
+         d=ScotchWhiskey[["norm"]],method="ward.D2",
+         ScotchWhiskey$neighbors@data,
+         coords=ScotchWhiskey$geo@coords/1000
+     )
> 
> ## A fonction to plot the Whiskey clustering results:
> 
> plotWhiskey <- function(wh, k) {
+    par(fig=c(0,1,0,1))
+    plot(grpWD2cst_ScotchWhiskey[[wh]], k=k, links=TRUE, las=1,
+         xlab="Eastings (km)", ylab="Northings (km)", cex=0.1, lwd=3,
+         main=sprintf("Feature: %s",wh))
+    text(ScotchWhiskey$geo@coords/1000,labels=1:length(ScotchWhiskey$geo))
+    legend(x=375, y=700, lty=1L, lwd=3, col=rainbow(1.2*k)[1L:k],
+           legend=sprintf("Group %d",1:k), cex=1.25)
+    SpeyZoom <- list(xlim=c(314.7,342.2), ylim=c(834.3,860.0))
+    rect(xleft=SpeyZoom$xlim[1L], ybottom=SpeyZoom$ylim[1L],col="#E6E6E680",
+         xright=SpeyZoom$xlim[2L], ytop=SpeyZoom$ylim[2L], lwd=2, lty=1L)
+    par(fig=c(0.01,0.50,0.46,0.99), new=TRUE)
+    plot(grpWD2cst_ScotchWhiskey[[wh]], xlim=SpeyZoom$xlim,
+         ylim=SpeyZoom$ylim, k=k, links=TRUE, las=1, xlab="", ylab="",
+         cex=0.1, lwd=3, axes=FALSE)
+    text(ScotchWhiskey$geo@coords/1000,labels=1:length(ScotchWhiskey$geo))
+    rect(xleft=SpeyZoom$xlim[1L], ybottom=SpeyZoom$ylim[1L],
+         xright=SpeyZoom$xlim[2L], ytop=SpeyZoom$ylim[2L], lwd=2, lty=1L)
+ }
> 
> ## Plot the clustering results on the map of Scotland for 5 groups.
> ## The inset map shows the Speyside distilleries in detail:
> plotWhiskey("nose", 5L)
> plotWhiskey("body", 5L)
> plotWhiskey("palate", 5L)
> plotWhiskey("finish", 5L)
> plotWhiskey("norm", 5L)
> 
> ## End of the Scotch Whiskey tasting data example
> 
> ## Not run: 
> ##D 
> ##D ## Third example: Fish community composition along the Doubs River,
> ##D ## France. The sequence is analyzed as a case of chronological
> ##D ## clustering, substituting space for time.
> ##D 
> ##D if(require("ade4", quietly = TRUE)){
> ##D data(doubs, package="ade4")
> ##D Doubs.D <- dist.ldc(doubs$fish, method="hellinger")
> ##D grpWD2cst_fish <- constr.hclust(Doubs.D, method="ward.D2", chron=TRUE,
> ##D                                 coords=as.matrix(doubs$xy))
> ##D plot(grpWD2cst_fish, k=5, las=1, xlab="Eastings (km)",
> ##D      ylab="Northings (km)", cex=3, lwd=3)
> ##D 
> ##D ## Repeat the plot with other values of k (number of groups)
> ##D 
> ##D ## End of the Doubs River fish assemblages example
> ##D 
> ##D ## Example with 6 connected points, shown in Fig. 2 of Guénard & Legendre paper 
> ##D 
> ##D var = c(1.5, 0.2, 5.1, 3.0, 2.1, 1.4)
> ##D ex.Y = data.frame(var)
> ##D 
> ##D ## Site coordinates, matrix xy
> ##D x.coo = c(-1, -2, -0.5, 0.5, 2, 1)
> ##D y.coo = c(-2, -1, 0, 0, 1, 2)
> ##D ex.xy = data.frame(x.coo, y.coo)
> ##D 
> ##D ## Matrix of connecting edges E
> ##D from = c(1,1,2,3,4,3,4)
> ##D to = c(2,3,3,4,5,6,6)
> ##D ex.E = data.frame(from, to)
> ##D 
> ##D ## Carry out constrained clustering analysis
> ##D test.out <-
> ##D     constr.hclust(
> ##D         dist(ex.Y),       # Response dissimilarity matrix
> ##D         method="ward.D2", # Clustering method
> ##D         links=ex.E,       # File of link edges (constraint) E
> ##D         coords=ex.xy      # File of geographic coordinates
> ##D     )
> ##D 
> ##D par(mfrow=c(1,2))
> ##D ## Plot the map of the results for k = 3
> ##D plot(test.out, k=3)
> ##D ## Plot the dendrogram
> ##D stats:::plot.hclust(test.out, hang=-1)
> ##D }
> ##D 
> ##D ## Same example modified: disjoint clusters
> ##D ## Same ex.Y and ex.xy as in the previous example
> ##D var = c(1.5, 0.2, 5.1, 3.0, 2.1, 1.4)
> ##D ex.Y = data.frame(var)
> ##D 
> ##D ## Site coordinates, matrix xy
> ##D x.coo = c(-1, -2, -0.5, 0.5, 2, 1)
> ##D y.coo = c(-2, -1, 0, 0, 1, 2)
> ##D ex.xy = data.frame(x.coo, y.coo)
> ##D 
> ##D ## Matrix of connecting edges E2
> ##D from = c(1,1,2,4,4)
> ##D to = c(2,3,3,5,6)
> ##D ex.E2 = data.frame(from, to)
> ##D 
> ##D ## Carry out constrained clustering analysis
> ##D test.out2 <-
> ##D     constr.hclust(
> ##D         dist(ex.Y),       # Response dissimilarity matrix
> ##D         method="ward.D2", # Clustering method
> ##D         links=ex.E2,      # File of link edges (constraint) E
> ##D         coords=ex.xy      # File of geographic coordinates
> ##D     )
> ##D cutree(test.out2, k=2)
> ##D 
> ##D par(mfrow=c(1,2))
> ##D ## Plot the map of the results for k = 3
> ##D plot(test.out2, k=3)
> ##D ## Plot the dendrogram showing the disconnected groups
> ##D stats:::plot.hclust(test.out2, hang=-1)
> ##D axis(2,at=0:ceiling(max(test.out2$height,na.rm=TRUE)))
> ##D 
> ##D ## End of the disjoint clusters example
> ##D 
> ## End(Not run)
> ## End of examples
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("constr.hclust", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("create.dbMEM.model")
> ### * create.dbMEM.model
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: create.dbMEM.model
> ### Title: Combine dbMEM matrices corresponding to groups of sites
> ### Aliases: create.dbMEM.model
> ### Keywords: spatial
> 
> ### ** Examples
> 
> {
+  # Generate random coordinates for 35 sites forming 6 distinct groups on the map
+  Easting <- runif(35)+c(rep(0,6),rep(1.5,7),rep(3,6), rep(0,5),rep(1.5,5),rep(3,6))
+  Northing<- runif(35)+c(rep(2.8,6),rep(2.3,7),rep(2.8,6), rep(0,5),rep(0.5,5),rep(0,6))
+  cartesian <- cbind(Easting,Northing)
+  rownames(cartesian) <- paste("S",1:nrow(cartesian),sep='')
+  nsites.per.group <- c(6,7,6,5,5,6)
+ 
+  result <- create.dbMEM.model(coord=cartesian, nsites=nsites.per.group)
+ 
+  # Draw a map to check the coding of the sites into the groups
+  site.codes <- unlist(apply(cbind(1:6),1,n=nsites.per.group,function(a,n) rep(a,n[a])))
+ 
+  col.vec <- c("green3","gray99","orange2","gold1","brown3","gray70")
+  plot(cartesian, pch=22, col="black", bg=col.vec[site.codes], cex=2, ylim=c(0,4),asp=1)
+  text(cartesian,labels=rownames(cartesian), cex=0.5, pos=3)
+ 
+  # Examine the staggered matrix of dbMEM eigenfunctions
+  # Not run:
+  result
+ }
       dbMEM.1    dbMEM.2    dbMEM.3     dbMEM.4    dbMEM.5     dbMEM.6
S1  -0.8262419  0.9792863  0.0000000  0.00000000  0.0000000  0.00000000
S2  -0.2432943  1.2003346  0.0000000  0.00000000  0.0000000  0.00000000
S3  -0.5853868 -1.7930505  0.0000000  0.00000000  0.0000000  0.00000000
S4   1.4205547 -0.4611652  0.0000000  0.00000000  0.0000000  0.00000000
S5  -1.0807338 -0.2540009  0.0000000  0.00000000  0.0000000  0.00000000
S6   1.3151020  0.3285957  0.0000000  0.00000000  0.0000000  0.00000000
S7   0.0000000  0.0000000 -0.9156818  0.81125096  0.0000000  0.00000000
S8   0.0000000  0.0000000 -0.7362006 -0.53656621  0.0000000  0.00000000
S9   0.0000000  0.0000000 -0.7434982 -0.51671908  0.0000000  0.00000000
S10  0.0000000  0.0000000  1.4982910 -0.08019703  0.0000000  0.00000000
S11  0.0000000  0.0000000  0.5124449 -1.82446586  0.0000000  0.00000000
S12  0.0000000  0.0000000  1.3070632  1.34510976  0.0000000  0.00000000
S13  0.0000000  0.0000000 -0.9224185  0.80158746  0.0000000  0.00000000
S14  0.0000000  0.0000000  0.0000000  0.00000000  0.9944868 -0.20145795
S15  0.0000000  0.0000000  0.0000000  0.00000000 -1.0059649  0.03804414
S16  0.0000000  0.0000000  0.0000000  0.00000000  1.0055168  0.03806875
S17  0.0000000  0.0000000  0.0000000  0.00000000 -1.0192275  1.68141905
S18  0.0000000  0.0000000  0.0000000  0.00000000 -0.9745288 -1.75749219
S19  0.0000000  0.0000000  0.0000000  0.00000000  0.9997176  0.20141819
S20  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S21  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S22  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S23  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S24  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S25  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S26  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S27  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S28  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S29  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S30  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S31  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S32  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S33  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S34  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
S35  0.0000000  0.0000000  0.0000000  0.00000000  0.0000000  0.00000000
         dbMEM.7    dbMEM.8    dbMEM.9      dbMEM.10   dbMEM.11   dbMEM.12
S1   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S2   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S3   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S4   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S5   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S6   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S7   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S8   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S9   0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S10  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S11  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S12  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S13  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S14  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S15  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S16  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S17  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S18  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S19  0.000000000  0.0000000  0.0000000  0.0000000000  0.0000000  0.0000000
S20 -1.118101810 -0.2899309  0.0000000  0.0000000000  0.0000000  0.0000000
S21 -1.121312143  1.0707553  0.0000000  0.0000000000  0.0000000  0.0000000
S22  1.117965417 -0.2958305  0.0000000  0.0000000000  0.0000000  0.0000000
S23  0.006721859 -1.5774685  0.0000000  0.0000000000  0.0000000  0.0000000
S24  1.114726677  1.0924746  0.0000000  0.0000000000  0.0000000  0.0000000
S25  0.000000000  0.0000000  1.1586520  0.0001631433  0.0000000  0.0000000
S26  0.000000000  0.0000000 -1.0668759 -1.5765545276  0.0000000  0.0000000
S27  0.000000000  0.0000000  1.1633574  0.0005270920  0.0000000  0.0000000
S28  0.000000000  0.0000000 -0.1926983 -0.0098151142  0.0000000  0.0000000
S29  0.000000000  0.0000000 -1.0624352  1.5856794066  0.0000000  0.0000000
S30  0.000000000  0.0000000  0.0000000  0.0000000000  0.8204886 -0.9712555
S31  0.000000000  0.0000000  0.0000000  0.0000000000 -1.3167044 -0.3353397
S32  0.000000000  0.0000000  0.0000000  0.0000000000  0.1894744 -1.2132536
S33  0.000000000  0.0000000  0.0000000  0.0000000000  1.0957559  0.2163743
S34  0.000000000  0.0000000  0.0000000  0.0000000000 -1.4057526  0.5302831
S35  0.000000000  0.0000000  0.0000000  0.0000000000  0.6167381  1.7731914
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("create.dbMEM.model", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("dbmem")
> ### * dbmem
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dbmem
> ### Title: dbMEM spatial eigenfunctions
> ### Aliases: dbmem
> 
> ### ** Examples
> 
> if(require("ade4", quietly = TRUE) & require("adegraphics", quietly = TRUE)){
+ 
+ data(oribatid)
+ mite <- oribatid$fau      # 70 peat cores, 35 species
+ mite.xy <- oribatid$xy    # Geographic coordinates of the 70 cores
+ 
+ # Example 1: Compute the MEMs corresponding to all non-null eigenvalues
+ # thresh=1.012 is the value used in Borcard and Legendre (2002)
+ mite.dbmem1 <- dbmem(mite.xy, thresh=1.012, MEM.autocor = "non-null", silent = FALSE)
+ mite.dbmem1
+ 
+ # Print the (n-1) non-null eigenvalues
+ attributes(mite.dbmem1)$values
+ # or:  attr(mite.dbmem1, "values")
+ 
+ # Plot the associated spatial weighting matrix
+ s.label(mite.xy, nb = attr(mite.dbmem1, "listw"))
+ 
+ # Plot maps of the first 3 dbMEM eigenfunctions
+ s.value(mite.xy, mite.dbmem1[,1:3])
+ 
+ # Compute and test associated Moran's I values
+ # Eigenvalues are proportional to Moran's I
+ 
+ test <- moran.randtest(mite.dbmem1, nrepet = 99)
+ plot(test$obs, attr(mite.dbmem1, "values"), xlab = "Moran's I", ylab = "Eigenvalues")
+ 
+ # Decreasing values of Moran's I for the successive MEM.
+ # The red line is the expected value of Moran's I under H0.
+ 
+ plot(test$obs, xlab="MEM rank", ylab="Moran's I")
+ abline(h=-1/(nrow(mite.xy) - 1), col="red")
+ 
+ # Example 2: Compute only the MEMs with positive eigenvalues (and positive Moran's I)
+ mite.dbmem2 <- dbmem(mite.xy, thresh=1.012)
+ # or:  mite.dbmem2 <- dbmem(dist(mite.xy), thresh=1.012, silent=FALSE)
+ mite.dbmem2
+ 
+ # Examine the eigenvalues
+ attributes(mite.dbmem2)$values
+ # or:  attr(mite.dbmem2, "values")
+ 
+ # Examine (any portion of) the dbmem spatial eigenvectors
+ tmp <- as.matrix(mite.dbmem2)
+ tmp[1:10,1:6]
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati


Attaching package: ‘adegraphics’

The following objects are masked from ‘package:ade4’:

    kplotsepan.coa, s.arrow, s.class, s.corcircle, s.distri, s.image,
    s.label, s.logo, s.match, s.traject, s.value, table.value,
    triangle.class

User-provided truncation threshold = 1.012 
Time to compute dbMEMs = 0.033000  sec 
         MEM1       MEM2         MEM3        MEM4       MEM5       MEM6
1  -0.1620574 -0.2982476 -0.035504650  0.11383777 -0.4341443 -0.2906948
2  -0.1947020 -0.4023768 -0.036135521 -0.03454869 -0.5620367 -0.4849196
3  -0.2136437 -0.4890009 -0.025861763 -0.21501361 -0.6354105 -0.6374601
4  -0.2565198 -0.6530629 -0.009275911 -0.46957393 -0.7150526 -0.7978259
5  -0.2598437 -0.7327767  0.027559734 -0.77345656 -0.4832301 -0.6799099
6  -0.3453581 -1.0090189  0.034869125 -1.05491045 -0.8388372 -1.1059744
7  -0.1686130 -0.3240952 -0.032762390  0.26178062 -0.6919921 -0.4455021
8  -0.4236748 -1.3670651  0.114272484 -1.66289601 -0.4438757 -0.8630065
9  -0.4423362 -1.4713133  0.147573019 -1.88814315 -0.1643492 -0.6274224
10 -0.3493720 -1.0831673  0.080660976 -1.06952479 -0.6256306 -0.8238873
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dbmem", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:adegraphics’, ‘package:ade4’

> nameEx("directional.response")
> ### * directional.response
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: directional.response
> ### Title: Directional indices of community change
> ### Aliases: directional.response
> 
> ### ** Examples
> 
> 
> # Artificial Example
> art <- c(1,1,1,0,0,0,
+          0,0,0,1,1,0,
+          0,0,0,0,0,1)
> art.data <- matrix(art, nrow=3, ncol=6, byrow=TRUE)
> 
> art.out <- directional.response(art.data, method="overlap",relativize=NULL)
Method:  overlap 
> 
> # Real data example: the Doubs River fish data (Verneaux 1973), available in ade4.
> # 30 sites, 27 species. No fish had been caught at site 8; remove that site
> if(require("ade4", quietly = TRUE)) {
+ 
+ data(doubs)
+ dim(doubs$fish)   
+ fish <- doubs$fish[-8,] 
+ dim(fish)
+ doubs.out <- directional.response(fish, method="gain", relativize="S")
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

Method:  gain 
Relativize with denominator: Sorensen
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("directional.response", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ade4’

> nameEx("dist.ldc")
> ### * dist.ldc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dist.ldc
> ### Title: Dissimilarity matrices for community composition data
> ### Aliases: dist.ldc
> 
> ### ** Examples
> 
> 
> if(require("vegan", quietly = TRUE)) {
+ data(mite)
+ mat1  = as.matrix(mite[1:10, 1:15])   # No column has a sum of 0
+ mat2 = as.matrix(mite[61:70, 1:15])   # 7 of the 15 columns have a sum of 0
+ 
+ #Example 1: compute Hellinger distance for mat1
+ D.out = dist.ldc(mat1,"hellinger")
+ 
+ #Example 2: compute chi-square distance for mat2
+ D.out = dist.ldc(mat2,"chisquare")
+ 
+ #Example 3: compute percentage difference dissimilarity for mat2
+ D.out = dist.ldc(mat2,"percentdiff")
+ 
+ }
This is vegan 2.6-6.1
Info -- This coefficient is Euclidean
Info -- This coefficient is Euclidean
Info -- For this coefficient, sqrt(D) would be Euclidean
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dist.ldc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("envspace.test")
> ### * envspace.test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: envspace.test
> ### Title: Perform a test of the shared space-environment fraction of a
> ###   variation partitioning using torus-translation (TT) or Moran Spectral
> ###   Randomisation (MSR)
> ### Aliases: envspace.test
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## No test: 
> if(require(vegan)) { 
+ # Illustration of the test of the SSEF on the oribatid mite data
+ # (Borcard et al. 1992, 1994 for details on the dataset):
+ # Community data (response matrix):
+ data(mite)
+ # Hellinger-transformation of the community data (Legendre and Gallagher 2001):
+ Y <- decostand(mite, method = "hellinger")
+ # Environmental explanatory dataset:
+ data(mite.env)
+ # We only use two numerical explanatory variables:
+ env <- mite.env[, 1:2]
+ dim(Y)
+ dim(env)
+ # Coordinates of the 70 sites:
+ data(mite.xy)
+ coord <- mite.xy
+ 
+ ### Building a list of candidate spatial weighting matrices (SWMs) for the 
+ ### optimisation of the SWM selection, separately for 'Y' and 'env':
+ # We create five candidate SWMs: a connectivity matrix based on a Gabriel graphs, on
+ # a minimum spanning tree (i.e., two contrasted graph-based SWMs), either
+ # not weighted, or weighted by a linear function decreasing with the distance),
+ # and a distance-based SWM corresponding to the connectivity and weighting
+ # criteria of the original PCNM method:
+ candidates <- listw.candidates(coord, nb = c("gab", "mst", "pcnm"), weights = c("binary",
+                                                                                 "flin"))
+ ### Optimisation of the selection of a SWM:
+ # SWM for 'Y' (based on the best forward-selected subset of MEM variables):
+ modsel.Y <- listw.select(Y, candidates, method = "FWD", MEM.autocor = "positive",
+                          p.adjust = TRUE)
+                          
+ names(candidates)[modsel.Y$best.id]                 # Best SWM selected
+ modsel.Y$candidates$Pvalue[modsel.Y$best.id]        # Adjusted p-value of the global model
+ modsel.Y$candidates$N.var[modsel.Y$best.id]         # Nb of forward-selected MEM variables
+ modsel.Y$candidates$R2Adj.select[modsel.Y$best.id]  # Adjusted R2 of the selected MEM var.
+ 
+ # SWM for 'env' (method = "global" for the optimisation, as all MEM variables are required
+ # to use MSR):
+ modsel.env <- listw.select(env, candidates, method = "global", MEM.autocor = "positive",
+                            p.adjust = TRUE)
+ 
+ names(candidates)[modsel.env$best.id]                  # Best SWM selected
+ modsel.env$candidates$Pvalue[modsel.env$best.id]       # Adjusted p-value of the global model
+ modsel.env$candidates$N.var[modsel.env$best.id]        # Nb of forward-selected MEM variables
+ modsel.env$candidates$R2Adj.select[modsel.env$best.id] # Adjusted R2 of the selected MEM var.
+ 
+ ### We perform the variation partitioning:
+ # Subset of selected MEM variables within the best SWM:
+ MEM.spe <- modsel.Y$best$MEM.select
+ 
+ VP <- varpart(Y, env, MEM.spe)
+ plot(VP)
+ 
+ # Test of the shared space-environment fraction (fraction [b]):
+ SSEF.test <- envspace.test(Y, env, coord, MEM.spe, 
+                            listw.env = candidates[[modsel.env$best.id]], 
+                            regular = FALSE, nperm = 999)
+ SSEF.test
+ 
+ # The SSEF is highly significant, indicating a potential induced spatial dependence.
+ }
Loading required package: vegan
Loading required package: permute
Loading required package: lattice
This is vegan 2.6-6.1
Warning in nb2listw(nb.object, style = style, glist = lapply(nb.dist, f1,  :
  zero sum general weights
Procedure stopped (adjR2thresh criteria) adjR2cum = 0.452381 with 11 variables (> 0.446534)
Procedure stopped (alpha criteria): pvalue for variable 14 is 0.072000 (> 0.050000)
Procedure stopped (alpha criteria): pvalue for variable 14 is 0.094000 (> 0.050000)
Procedure stopped (alpha criteria): pvalue for variable 13 is 0.055000 (> 0.050000)
Procedure stopped (alpha criteria): pvalue for variable 16 is 0.067000 (> 0.050000)
Monte-Carlo test
Call: as.randtest(sim = E.b, obs = R2.b, alter = alternative)

Observation: 0.21545 

Based on 999 replicates
Simulated p-value: 1 
Alternative hypothesis: greater 

     Std.Obs  Expectation     Variance 
-2.925866934  0.408886617  0.004370875 
> ## End(No test)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("envspace.test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("forward.sel")
> ### * forward.sel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: forward.sel
> ### Title: Forward selection with multivariate Y using permutation under
> ###   reducel model
> ### Aliases: forward.sel
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> 
> x <- matrix(rnorm(30),10,3)
> y <- matrix(rnorm(50),10,5)
>     
> forward.sel(y,x,nperm=99, alpha = 0.5)
Testing variable 1
Testing variable 2
Procedure stopped (alpha criteria): pvalue for variable 2 is 0.620000 (> 0.500000)
  variables order        R2     R2Cum  AdjR2Cum       F pvalue
1        V1     1 0.2034752 0.2034752 0.1039096 2.04363    0.1
>  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("forward.sel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("forward.sel.par")
> ### * forward.sel.par
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: forward.sel.par
> ### Title: Parametric forward selection of explanatory variables in
> ###   regression and RDA
> ### Aliases: forward.sel.par
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> 
> x <- matrix(rnorm(30),10,3)
> y <- matrix(rnorm(50),10,5)
>     
> forward.sel.par(y,x, alpha = 0.5)
The variables in response matrix Y have been standardized 
Procedure stopped (alpha criterion): pvalue for variable  2  is  0.8281374 
  variable order        R2     R2cum  AdjR2Cum        F       pval
1       V1     1 0.2029731 0.2029731 0.1033447 2.037302 0.09400334
2       V3     3 0.1061698 0.3091429 0.1117551 1.075748 0.39057216
>  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("forward.sel.par", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("give.thresh")
> ### * give.thresh
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: give.thresh
> ### Title: Compute the maximum distance of the minimum spanning tree based
> ###   on a distance matrix
> ### Aliases: give.thresh
> 
> ### ** Examples
> 
> xy <- matrix(rnorm(60),30,2)
> dxy <- dist(xy)
> th <- give.thresh(dxy)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("give.thresh", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("global.rtest")
> ### * global.rtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: global.rtest
> ### Title: Global and local tests
> ### Aliases: global.rtest local.rtest
> ### Keywords: multivariate spatial
> 
> ### ** Examples
> 
> 
> 
> # wait for a generic dataset
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("global.rtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("listw.candidates")
> ### * listw.candidates
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: listw.candidates
> ### Title: Function to create a list of spatial weighting matrices
> ### Aliases: listw.candidates
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ### Create 100 random sampling locations in a squared grid of 120 x 120:
> xy <- matrix(nrow = 100, ncol = 2)
> xy[, 1] <- sample(c(1:120), 100, replace = FALSE)
> xy[, 2] <- sample(c(1:120), 100, replace = FALSE)
> ### The function listw.candidates is used to build the spatial weighting matrices that
> ### we want to test and compare (with the listw.select function). We test a Gabriel's graph, 
> ### a minimum spanning tree, and a distance-based connectivity defined by a threshold
> ### distance corresponding to the smallest distance keeping all sites connected (i.e., 
> ### the defaut value of d2). These connectivity matrices are then either not weighted 
> ### (binary weighting), or weighted by the linearly decreasing function:
> candidates <- listw.candidates(coord = xy, nb = c("gab", "mst", "dnear"), 
+                                weights = c("binary", "flin"))
> names(candidates)                              
[1] "Gabriel_Binary"    "Gabriel_Linear"    "MST_Binary"       
[4] "MST_Linear"        "Dnear20.88_Binary" "Dnear20.88_Linear"
> plot(candidates[[1]], xy)
> plot(candidates[[3]], xy)
> ### Construction of a different list of spatial weighting matrices. This time, the
> ### connexions are defined by a distance-based criterion based on the same threshold
> ### value, but the connections are weighted by the concave-down function with a y parameter
> ### varying between 2 and 5, and a concave-up function with a y parametre of 0.2.
> candidates2 <- listw.candidates(coord = xy, nb = "dnear", weights = c("fdown", "fup"),
+                                 y_fdown = 1:5, y_fup = 0.2)
> ### Number of spatial weighting matrices generated:
> length(candidates2) 
[1] 6
> ### A single SWM can also easily be generated with listw.candidates:
> lw <- listw.candidates(xy, nb = "gab", weights = "bin")
> plot(lw[[1]], xy)
> 
> ### Generating MEM variables from an object of listw.candidates with scores.listw:
> MEM <- scores.listw(lw[[1]])
> ### See functions mem.select and listw.select for examples of how to use an object
> ### created by listw.candidates with these functions.
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("listw.candidates", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("listw.explore")
> ### * listw.explore
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: listw.explore
> ### Title: Interactive tool to generate R code that creates a spatial
> ###   weighting matrix
> ### Aliases: listw.explore
> 
> ### ** Examples
> 
> if(interactive()){
+ ## a matrix or an object of class 'Spatial*' should be in the global environment
+ xy <- matrix(rnorm(50), 25)
+ listw.explore()
+ }
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("listw.explore", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("listw.select")
> ### * listw.select
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: listw.select
> ### Title: Function to optimize the selection of a spatial weighting matrix
> ###   and select the best subset of eigenvectors (MEM, Moran's Eigenvector
> ###   Maps)
> ### Aliases: listw.select
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## No test: 
> if(require(spdep)) {
+ ### Create a grid of 15 x 15:
+ grid <- expand.grid(x = seq(1, 15, 1), y = seq(1, 15, 1))
+ ### Generate a response variable Y structured at broad scale by linear combination of
+ ### the first three MEM variables to which a normal noise is added:
+ nb <- cell2nb(nrow = 15, ncol = 15, "queen")
+ lw <- nb2listw(nb, style = "B")
+ MEM <- scores.listw(lw, MEM.autocor = "positive")
+ # Degree of spatial autocorrelation:
+ intensity <- 0.8
+ Y_space <- scale(MEM[, 1] + MEM[, 2] + MEM[, 3]) * intensity
+ Y_noise <- scale(rnorm(n = nrow(MEM), mean = 0, sd = 1)) * (1 - intensity)
+ Y <- Y_space + Y_noise
+ ### Y is sampled in 100 randomly-chosen sites of the grid:
+ idx.sample <- sample(c(1:nrow(grid)), 100, replace = FALSE)
+ xy <- grid[idx.sample, ]
+ Y_sampled <- Y[idx.sample]
+ ### The function listw.candidates is used to build the spatial weighting matrices that
+ ### we want to test and compare (with the listw.select function). We test a Gabriel's graph,
+ ### a minimum spanning tree, and a distance-based connectivity defined by a threshold
+ ### distance corresponding to the smallest distance keeping all sites connected (i.e.,
+ ### the defaut value of d2; see help of function listw.candidates).
+ ### These connectivity matrices are then either not weighted (binary weighting), or
+ ### weighted by the linearly decreasing function (see help of the function listw.candidates):
+ candidates <- listw.candidates(coord = xy, nb = c("gab", "mst"), weights = c("binary", "flin"))
+ ### Number of candidate W matrices generated:
+ nbw <- length(candidates)
+ ### Significance threshold value after p-value correction (Sidak correction):
+ 1 - (1 - 0.05)^(1/nbw)
+ ### Optimization of the selection of the SWM among the candidates generated above,
+ ### using the corrected significance threshold calculated above for the global tests:
+ W_sel <- listw.select(Y_sampled, candidates, MEM.autocor = "positive", method = "FWD",
+                     p.adjust = TRUE, nperm = 299)
+ ### Some characteristics of the best spatial model:
+ # Best SWM:
+ W_sel$best.id
+ # Selected subset of spatial predictor within the best SWM:
+ W_sel$best$MEM.select
+ nrow(W_sel$best$summary)
+ # Corrected p-value of the global test of the best SWM:
+ W_sel$best$global.test$Pvalue
+ # Adjusted R2 of the subset of spatial predictors selected within the chosen SWM:
+ max(W_sel$best$summary$R2Adj)
+ # p-values of all the tested W matrices:
+ W_sel$candidates$Pvalue
+ # Adjusted R2 of the subset of spatial predictors selected for all the significant
+ # W matrices:
+ W_sel$candidates$R2Adj.select
+ 
+ # See Appendix S3 of Bauman et al. 2018 for more extensive examples and illustrations.
+ }
Loading required package: spdep
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
Procedure stopped (alpha criteria): pvalue for variable 16 is 0.060000 (> 0.050000)
Procedure stopped (adjR2thresh criteria) adjR2cum = 0.933143 with 25 variables (> 0.930827)
Procedure stopped (alpha criteria): pvalue for variable 18 is 0.066667 (> 0.050000)
Procedure stopped (adjR2thresh criteria) adjR2cum = 0.787776 with 21 variables (> 0.780877)
Warning in max(W_sel$best$summary$R2Adj) :
  no non-missing arguments to max; returning -Inf
[1] 0.9264479 0.9304582 0.8039824 0.7805985
> ## End(No test)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("listw.select", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("mem")
> ### * mem
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: scores.listw
> ### Title: Function to compute and manage Moran's Eigenvector Maps (MEM) of
> ###   a listw object
> ### Aliases: scores.listw mem orthobasis.listw [.orthobasisSp
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE) & require("spdep", quietly = TRUE)){
+ data(oribatid)
+ nbtri <- tri2nb(as.matrix(oribatid$xy))
+ sc.tri <- scores.listw(nb2listw(nbtri, style = "B"))
+ summary(sc.tri)
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

Orthonormal basis: data.frame with 70 rows and 69 columns
----------------------------------------------------------------
Columns form a centred orthonormal basis (i.e. 1n-orthogonal)
for the inner product defined by the 'weights' attribute
----------------------------------------------------------------

Attributes:
- names: MEM1 ... MEM69 
- row.names: 1 ... 70 
- weights: 0.01428571 ... 0.01428571 
- values: 0.07805391 ... -0.04134591 
- class: orthobasisSp orthobasis data.frame 
- call: scores.listw(listw = nb2listw(nbtri, style = "B")) 

> if(require("adegraphics", quietly = TRUE)){
+ s.value(oribatid$xy,sc.tri[,1:9])
+ plot(sc.tri[,1:6], oribatid$xy, pSp.cex = 5, pSp.alpha = 0.5, pbackground.col = 'lightblue')
+ }

Attaching package: ‘adegraphics’

The following objects are masked from ‘package:ade4’:

    kplotsepan.coa, s.arrow, s.class, s.corcircle, s.distri, s.image,
    s.label, s.logo, s.match, s.traject, s.value, table.value,
    triangle.class

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mem", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:adegraphics’, ‘package:spdep’, ‘package:sf’,
  ‘package:spData’, ‘package:ade4’

> nameEx("mem.select")
> ### * mem.select
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mem.select
> ### Title: Selection of the best subset of spatial eigenvectors (MEM,
> ###   Moran's Eigenvector Maps)
> ### Aliases: mem.select
> ### Keywords: spatial
> 
> ### ** Examples
> 
> if(require(vegan)){ 
+ # Illustration of the MIR selection on the oribatid mite data
+ # (Borcard et al. 1992, 1994 for details on the dataset):
+ # *******************************************************
+ # Community data (response matrix):
+ data(mite)
+ # We will compute the example on a single species:
+ spe <- mite[, 2]
+ # Environmental explanatory dataset:
+ data(mite.env)
+ # We only use two numerical explanatory variables:
+ env <- mite.env[, 1:2]
+ dim(env)
+ # Coordinates of the 70 sites:
+ data(mite.xy)
+ coord <- mite.xy
+ # We build the model we are interested in:
+ mod <- lm(spe ~ ., data = env)
+ 
+ 
+ # In order to avoid possible type I error rate inflation issues, we check 
+ # whether the model residuals are independent, and if they are spatially
+ # autocorrelated, we select a small subset of MEM variables to add to the
+ # model as covariables with the MIR selection:
+ 
+ # 1) We build a spatial weighting matrix based on Gabriel graph with a
+ # weighting function decreasing linearly with the distance:
+ w <- listw.candidates(coord, nb = "gab", weights = "flin")
+ 
+ 
+ # 2) We test the spatial autocorrelation of the model residuals and, if
+ # necessary, select a subset of spatial predictors:
+ y <- residuals(mod)
+ MEM <- mem.select(x = y, listw = w[[1]], method = "MIR", MEM.autocor = "positive",
+          nperm = 999, alpha = 0.05)
+ dim(MEM$MEM.select)
+ # The residuals of the model presented spatial autocorrelation. The selection
+ # of MEM variables is thus performed to remove residual autocorrelation.
+ 
+ # 3) We can reconstruct our model adding the selected MEM variable as covariables:
+ env2 <- cbind(env, MEM$MEM.select)
+ mod_complete <- lm(spe ~ ., data = env2)
+ summary(mod_complete)$coefficient[, 1]   # Coefficient estimates
+ summary(mod_complete)$coefficient[, 2]   # Standard errors
+ }
Loading required package: vegan
Loading required package: permute
Loading required package: lattice
This is vegan 2.6-6.1
(Intercept)    SubsDens    WatrCont        MEM6        MEM5 
0.763474835 0.017891034 0.001448202 0.198312047 0.191102035 
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mem.select", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("mfpa")
> ### * mfpa
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mfpa
> ### Title: Multi-frequential periodogram analysis
> ### Aliases: mfpa plot.mfpa print.mfpa
> 
> ### ** Examples
> 
> 
> ### Example 1
> 
> # Simulate data with frequencies 2.3 and 6.1 and a random component, n = 100. 
> # No trend, no autocorrelated residuals.
> 
> y <- as.matrix(0.4*(sin(2.3*2*pi*(1:100)/100)) +
+ 0.4*(sin(6.1*2*pi*(1:100)/100)) + 0.2*rnorm(100))
> 
> res <- mfpa(y, MaxNFreq = 2, MinFreq = 2, ntrend = 0, nlags = 0)
> 
> # Compute the periods associated with the two periodic components. Each
> # frequency in element $frequencies is a number of cycles in the whole series.
> # The periods are expressed in numbers of time intervals of the data series. In
> # this example, if the data are measured every min, the periods are in min.
> 
> periods <- 100/res$frequencies$frequency 
> 
> # Draw the data series and the fitted (or predicted) values
> 
> plot(res)
> 
> ### Example 2
> 
> # Generate hourly periodic data with tide signal (tide period T = 12.42 h)
> # during 1 year, hence 24*365 = 8760 hourly data. See
> # https://en.wikipedia.org/wiki/Tide.
> 
> # In this simulation, constant (c = 0) puts the maximum value of the cosine at
> # midnight on the first day of the series.
> 
> periodic.component <- function(x, T, c) cos((2*pi/T)*(x+c))
> 
> tide.h <- periodic.component(1:8760, 12.42, 0)
> 
> # The number of tides in the series is: 8760/12.42 = 705.314 tidal cycles
> # during one year.
> 
> # Sample the hourly data series once a day at 12:00 noon every day. The
> # periodic signal to be detected has a period smaller then the interval between
> # consecutive observations and its frequency is larger than (n-1). The sequence
> # of sampling hours for the tide.h data is:
> 
> h.noon <- seq(12, 8760, 24) 
> tide.data <- tide.h[h.noon]
> length(tide.data)   
[1] 365
> 
> # The series contains 365 sampling units
> 
> # Compute Dutilleul's multi-frequential periodogram
> 
> res.noon <- mfpa(tide.data, MaxNFreq = 1, MinFreq = 2, ntrend = 1, nlags = 2)
> 
> # Examine the frequency detected by the periodogram, element
> # res.noon$frequencies. This is a harmonic of the tide signal in the original
> # data series tide.h.
> 
> # Compute the period of the signal in the data series sampled hourly:
> 
> period <- 365/res.noon$frequencies$frequency
> 
> # Draw the data series and the adjusted values
> 
> plot(res.noon)
> 
> # Repeat this analysis after addition of random noise to the tide data
> 
> tide.noise <- tide.data + rnorm(365, 0, 0.25)
> 
> res.noise <- mfpa(tide.noise, MaxNFreq = 1, MinFreq = 2, ntrend = 1, nlags = 2)
> 
> plot(res.noise)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mfpa", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("moran.bounds")
> ### * moran.bounds
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moran.bounds
> ### Title: Function to compute extreme values of Moran's I
> ### Aliases: moran.bounds
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE)){
+  if(require("spdep", quietly = TRUE)){
+      data(oribatid)
+      nbtri <- tri2nb(as.matrix(oribatid$xy))
+      lwB <- nb2listw(nbtri, style = "B")
+      lwW <- nb2listw(nbtri, style = "W")
+      scB <- mem(lwB)
+      scW <- mem(lwW)
+      moran.bounds(lwB)
+      moran.mc(scB[,1], lwB, 9)
+      moran.mc(scB[,69], lwB, 9)
+      moran.bounds(lwW)
+      moran.mc(scW[,1], lwW, 9)
+      moran.mc(scW[,69], lwW, 9)
+  }
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree


	Monte-Carlo simulation of Moran I

data:  scW[, 69] 
weights: lwW  
number of simulations + 1: 10 

statistic = -0.5473, observed rank = 1, p-value = 0.9
alternative hypothesis: greater

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moran.bounds", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’,
  ‘package:ade4’

> nameEx("moran.randtest")
> ### * moran.randtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moran.randtest
> ### Title: Function to compute Moran's index of spatial autocorrelation
> ### Aliases: moran.randtest
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE)  & require("spdep", quiet = TRUE)){
+ data(mafragh)
+ tests <- moran.randtest(mafragh$env, nb2listw(mafragh$nb))
+ tests
+ plot(tests)
+ 
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moran.randtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’,
  ‘package:ade4’

> nameEx("moranNP.randtest")
> ### * moranNP.randtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: moranNP.randtest
> ### Title: Function to compute positive and negative parts of Moran's index
> ###   of spatial autocorrelation
> ### Aliases: moranNP.randtest
> ### Keywords: spatial
> 
> ### ** Examples
> 
> if(require("ade4", quietly = TRUE)  & require("spdep", quiet = TRUE)){
+ data(mafragh)
+ tests <- moranNP.randtest(mafragh$env[,1], nb2listw(mafragh$nb),
+  alter = "two-sided", p.adjust.method = "holm")
+ tests
+ moran.randtest(mafragh$env[,1], nb2listw(mafragh$nb))$obs
+ sum(tests$obs)
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

[1] 0.430624
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("moranNP.randtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’,
  ‘package:ade4’

> nameEx("mspa")
> ### * mspa
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mspa
> ### Title: Multi-Scale Pattern Analysis
> ### Aliases: mspa print.mspa scatter.mspa
> ### Keywords: multivariate spatial
> 
> ### ** Examples
> 
> 
> 
> ####################################
> ### using oribatib mites dataset ###
> ####################################
> 
> if(require("ade4", quietly = TRUE)){
+ ## load data
+ data(oribatid)
+ 
+ ## get the list of spatial weights
+ cn <- chooseCN(oribatid$xy, res = "listw", ask = FALSE, type = 1)
+ 
+ ## Hellinger transformation
+ hellTrans <- function(X){
+   if (!( is.matrix(X) | is.data.frame(X) )) stop("Object is not a matrix.")  
+   if (any(is.na(X))) stop("na entries in table.")
+   
+   sumRow <- apply(X,1,sum)
+   Y <- X/sumRow
+   Y <- sqrt(Y)
+   
+   return(Y)
+ }
+ 
+ 
+ ## ENVIRONMENTAL VARIABLES ##
+ ## Hill and Smith analysis for environmental variables
+ ## (for a mixture of quantitative / qualitative variables)
+ hsEnv <- dudi.hillsmith(oribatid$envir,scannf=FALSE)
+ 
+ ## detrending of the analysis (residuals of regression onto xy coordinates)
+ hsEnv.detr <- pcaivortho(hsEnv,oribatid$xy,scannf=FALSE)
+ 
+ ## MSPA of the detrended analysis
+ mspaEnv <- mspa(hsEnv.detr,cn,scannf=FALSE,nf=2)
+ scatter(mspaEnv)
+ 
+ 
+ 
+ ## SPECIES DATA ##
+ ## PCA of species abundances, after Hellinger transformation
+ pcaFau <- dudi.pca(hellTrans(oribatid$fau),scale=FALSE,scannf=FALSE)
+ 
+ ## detrending of this PCA
+ pcaFau.detr <- pcaivortho(pcaFau,oribatid$xy,scannf=FALSE)
+ 
+ # MSPA of the detrended analysis
+ mspaFau <- mspa(pcaFau.detr,cn,scannf=FALSE,nf=2)
+ scatter(mspaFau)
+ 
+ 
+ 
+ ## CANONICAL MSPA ##
+ ## RDA species ~ envir
+ ## (species abundances predicted by environment)
+ ## note: RDA = 'PCAIV' (PCA with Instrumental Variables)
+ rda1 <- pcaiv(dudi=pcaFau.detr, df=oribatid$envir,scannf=FALSE,nf=2)
+ 
+ ## canonical MSPA (species predicted by environment)
+ mspaCan1 <- mspa(dudi=rda1, lw=cn, scannf=FALSE, nf=2)
+ scatter(mspaCan1)
+ 
+ ## same analysis, using a non-parametric centring
+ mspaCan1NP <- mspa(dudi=rda1, lw=cn, scannf=FALSE, nf=2,cent="sim",nper=999)
+ scatter(mspaCan1NP) # basically no change
+ 
+ 
+ 
+ ## PARTIAL CANONICAL MSPA ##
+ ## partial RDA species ~ envir
+ ## (species abundances not predicted by environment)
+ rda2 <- pcaivortho(dudi=pcaFau.detr,df=oribatid$envir,scannf=FALSE,nf=2)
+ 
+ ## partial canonical MSPA
+ mspaCan2 <- mspa(dudi=rda2, lw=cn, scannf=FALSE, nf=2)
+ scatter(mspaCan2) # nothing left
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mspa", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ade4’

> nameEx("msr.4thcorner")
> ### * msr.4thcorner
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: msr.4thcorner
> ### Title: Moran spectral randomization for fourth-corner analysis
> ### Aliases: msr.4thcorner
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE) & require("adephylo", quietly = TRUE)
+ & require("spdep", quietly = TRUE) & require("ape", quietly = TRUE)){
+ data(mafragh, package = "ade4")
+ fr1 <- fourthcorner(mafragh$env, mafragh$flo, mafragh$traits$tabQuantitative, nrepet = 49)
+ phy <- read.tree(text = mafragh$tre)
+ lw <- nb2listw(mafragh$nb)
+ fr1.msr <- msr(fr1, listwORorthobasis = lw, phyloORorthobasis = phy)
+ 
+ fr1
+ fr1.msr
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

Fourth-corner Statistics
------------------------
Permutation method  msr  ( 49  permutations)

Adjustment method for multiple comparisons:   holm 
call:  msr.4thcorner(x = fr1, listwORorthobasis = lw, phyloORorthobasis = phy) 

---

                        Test Stat          Obs     Std.Obs     Alter Pvalue
1                 Clay / Lfp    r  0.014241856  0.37798971 two-sided   0.76
2                 Silt / Lfp    r -0.076256133 -1.26763875 two-sided   0.22
3                 Sand / Lfp    r  0.063614861  0.83334782 two-sided   0.34
4                  K2O / Lfp    r  0.031979355  0.82856950 two-sided   0.38
5                 Mg++ / Lfp    r  0.014982765  0.30633314 two-sided   0.74
6             Na+/100g / Lfp    r  0.093499930  1.52213386 two-sided   0.16
7                   K+ / Lfp    r  0.149968927  1.26487047 two-sided   0.26
8         Conductivity / Lfp    r  0.080497038  1.29479275 two-sided    0.2
9            Retention / Lfp    r -0.067943687 -0.87385859 two-sided   0.36
10               Na+/l / Lfp    r  0.063272819  1.11421112 two-sided    0.3
11           Elevation / Lfp    r -0.129537428 -1.41717283 two-sided   0.16
12         Clay / Min height    r  0.061180871  1.49203452 two-sided   0.14
13         Silt / Min height    r -0.052382325 -1.22638955 two-sided    0.3
14         Sand / Min height    r -0.027907397 -0.68614059 two-sided   0.48
15          K2O / Min height    r  0.047550545  1.02326221 two-sided   0.34
16         Mg++ / Min height    r -0.023023055 -0.46012454 two-sided   0.62
17     Na+/100g / Min height    r  0.027191299  0.50031156 two-sided   0.66
18           K+ / Min height    r  0.095029793  1.79565176 two-sided   0.08
19 Conductivity / Min height    r -0.018899856 -0.37223394 two-sided    0.7
20    Retention / Min height    r  0.004165428  0.28708090 two-sided   0.72
21        Na+/l / Min height    r -0.046119268 -0.90523804 two-sided   0.38
22    Elevation / Min height    r  0.061211127  0.91575883 two-sided   0.34
23         Clay / Max height    r  0.010762151  0.31682260 two-sided   0.84
24         Silt / Max height    r -0.030835126 -0.82629157 two-sided   0.46
25         Sand / Max height    r  0.027229507  0.52148836 two-sided   0.68
26          K2O / Max height    r  0.063923177  1.31693995 two-sided   0.24
27         Mg++ / Max height    r  0.010886210  0.10602503 two-sided   0.86
28     Na+/100g / Max height    r  0.026525395  0.67807070 two-sided   0.42
29           K+ / Max height    r  0.109401849  1.94923641 two-sided   0.04
30 Conductivity / Max height    r  0.002446542  0.13245966 two-sided   0.86
31    Retention / Max height    r -0.005456736  0.04307117 two-sided      1
32        Na+/l / Max height    r -0.018577793 -0.45671050 two-sided    0.6
33    Elevation / Max height    r  0.033495574  0.80611903 two-sided   0.42
   Pvalue.adj  
1           1  
2           1  
3           1  
4           1  
5           1  
6           1  
7           1  
8           1  
9           1  
10          1  
11          1  
12          1  
13          1  
14          1  
15          1  
16          1  
17          1  
18          1  
19          1  
20          1  
21          1  
22          1  
23          1  
24          1  
25          1  
26          1  
27          1  
28          1  
29          1  
30          1  
31          1  
32          1  
33          1  

---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("msr.4thcorner", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ape’, ‘package:spdep’, ‘package:sf’,
  ‘package:spData’, ‘package:adephylo’, ‘package:ade4’

> nameEx("msr")
> ### * msr
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: msr
> ### Title: Moran spectral randomization
> ### Aliases: msr msr.default
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> library(spdep)
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
> x1 <- matrix(rnorm(81*5), nrow = 81)
> lw1 <- nb2listw(cell2nb(9, 9))
> 
> moran.mc(x1[,1], lw1, 2)$statistic
   statistic 
-0.008565073 
> 
> ## singleton
> x1.1 <- msr(x1[,1], lw1, nrepet = 9, method = "singleton")
> apply(x1.1, 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.008565073 -0.008565073 -0.008565073 -0.008565073 -0.008565073
[6] -0.008565073 -0.008565073 -0.008565073 -0.008565073
> 
> ## triplet
> x1.2 <- msr(x1[,1], lw1, nrepet = 9, method = "triplet")
> apply(x1.2, 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.008565073 -0.008565073 -0.008565073 -0.008565073 -0.008565073
[6] -0.008565073 -0.008565073 -0.008565073 -0.008565073
> 
> ## pair
> x1.3 <- msr(x1[,1], lw1, nrepet = 9, method = "pair")
> apply(x1.3, 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.0066606926 -0.0022805432 -0.0069969594 -0.0029250560 -0.0004496634
[6] -0.0060028507 -0.0064729768 -0.0004938065 -0.0072051811
> 
> ## pair with cor.fixed
> x1.4 <- msr(x1[,1], lw1, nrepet = 9, cor.fixed = 0.5)
> apply(x1.4, 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.0054801996 -0.0029512875 -0.0014770177 -0.0062360246  0.0001196211
[6] -0.0004013360 -0.0007233419  0.0006859294  0.0007745817
> cor(x1[,1], x1.4)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
[1,]  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
> 
> ## pair preserving correlations for multivariate data
> x1.5 <- msr(x1, lw1, nrepet = 9, cor.fixed = 0.5)
> cor(x1)
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000
> lapply(x1.5, cor)
[[1]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[2]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[3]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[4]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[5]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[6]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[7]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[8]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[9]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

> 
> apply(x1, 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.008565073  0.071772752  0.068564483 -0.057580154  0.032645357
> apply(x1.5[[1]], 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.003921677  0.071064553  0.072917225 -0.055522360  0.033544499
> 
> ## singleton preserving correlations for multivariate data
> x1.6 <- msr(x1, lw1, nrepet = 9, method = "singleton")
> cor(x1)
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000
> lapply(x1.6, cor)
[[1]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[2]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[3]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[4]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[5]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[6]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[7]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[8]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

[[9]]
              [,1]          [,2]        [,3]        [,4]        [,5]
[1,]  1.000000e+00 -4.038783e-05 -0.11080932  0.13039885  0.04886913
[2,] -4.038783e-05  1.000000e+00 -0.02422280 -0.21167452  0.08501603
[3,] -1.108093e-01 -2.422280e-02  1.00000000  0.10590282 -0.08736263
[4,]  1.303989e-01 -2.116745e-01  0.10590282  1.00000000 -0.08320125
[5,]  4.886913e-02  8.501603e-02 -0.08736263 -0.08320125  1.00000000

> 
> apply(x1, 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.008565073  0.071772752  0.068564483 -0.057580154  0.032645357
> apply(x1.6[[1]], 2, function(x) moran.mc(x, listw = lw1, nsim = 2)$statistic)
[1] -0.008565073  0.071772752  0.068564483 -0.057580154  0.032645357
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("msr", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("msr.mantelrtest")
> ### * msr.mantelrtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: msr.mantelrtest
> ### Title: Moran spectral randomization for Mantel test
> ### Aliases: msr.mantelrtest
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE)
+ & require("spdep", quietly = TRUE)){
+ data(mafragh, package = "ade4")
+ 
+ d1 <- dist(mafragh$env[,1:3])
+ d2 <- dist(mafragh$env[,7])
+ t1 <- mantel.randtest(d1,d2)
+ t1
+ 
+ lw <- nb2listw(mafragh$nb)
+ t2 <- msr(t1, listwORorthobasis = lw)
+ t2
+ 
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

Warning in is.euclid(dX) : Zero distance(s)
Warning in is.euclid(distmat) : Zero distance(s)
Monte-Carlo test
Call: msr.mantelrtest(x = t1, listwORorthobasis = lw)

Observation: 0.1197583 

Based on 999 replicates
Simulated p-value: 0.188 
Alternative hypothesis: greater 

    Std.Obs Expectation    Variance 
0.874171246 0.043180356 0.007673874 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("msr.mantelrtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’,
  ‘package:ade4’

> nameEx("msr.varipart")
> ### * msr.varipart
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: msr.varipart
> ### Title: Moran spectral randomization for variation partitioning
> ### Aliases: msr.varipart
> 
> ### ** Examples
> 
> library(ade4)

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

> library(spdep)
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

> data(mafragh)
> ## Performing standard variation partitioning
> dudiY <- dudi.pca(mafragh$flo, scannf = FALSE, scale = FALSE)
> mafragh.lw <- nb2listw(mafragh$nb)
> me <- mem(mafragh.lw, MEM.autocor = "positive")
> vprda <- varipart(dudiY, mafragh$env, me, type = "parametric")
> 
> ## Adjust estimation and compute p-value by msr methods
> vprda.msr <- msr(vprda, mafragh.lw, nrepet=99)
> vprda.msr
Variation Partitioning
class: varipart list 

Test of fractions:
Monte-Carlo test
Call: msr.varipart(x = vprda, listwORorthobasis = mafragh.lw, nrepet = 99)

Observation: 0.2366554 

Based on 99 replicates
Simulated p-value: 0.01 
Alternative hypothesis: greater 

     Std.Obs  Expectation     Variance 
2.4544804883 0.1803158972 0.0005268738 

Individual fractions:
         a          b          c          d 
0.06295763 0.17369775 0.42438794 0.33895668 

Adjusted fractions:
          a           b           c           d 
-0.01340023  0.08213340  0.26390433  0.66736250 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("msr.varipart", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’,
  ‘package:ade4’

> nameEx("mst.nb")
> ### * mst.nb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mst.nb
> ### Title: Function to compute neighborhood based on the minimum spanning
> ###   tree
> ### Aliases: mst.nb
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> xy <- matrix(rnorm(60),30,2)
> dxy <- dist(xy)
> th <- give.thresh(dxy)
> nb1 <- mst.nb(dxy)
> nb1
Neighbour list object:
Number of regions: 30 
Number of nonzero links: 58 
Percentage nonzero weights: 6.444444 
Average number of links: 1.933333 
> wh1 <- which(as.matrix(dxy)==th,arr.ind=TRUE)
> plot(nb1,xy,pch=20,cex=2,lty=3)
> lines(xy[wh1[1,],1],xy[wh1[1,],2],lwd=2)
> title(main="Maximum distance of the minimum spanning tree in bold")
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mst.nb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("multispati")
> ### * multispati
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: multispati
> ### Title: Multivariate spatial analysis
> ### Aliases: multispati plot.multispati summary.multispati print.multispati
> ### Keywords: multivariate spatial
> 
> ### ** Examples
> 
> 
> 
> if (require(spdep, quiet = TRUE) & require(ade4, quiet = TRUE)) {
+     data(mafragh)
+     maf.xy <- mafragh$xy
+     maf.flo <- mafragh$flo
+     maf.listw <- nb2listw(mafragh$nb)
+     if(adegraphicsLoaded()) {
+       g1 <- s.label(maf.xy, nb = mafragh$nb, plab.cex = 0.75)
+     } else {
+       s.label(maf.xy, neig = mafragh$neig, clab = 0.75)
+     }
+     maf.coa <- dudi.coa(maf.flo,scannf = FALSE)
+     maf.coa.ms <- multispati(maf.coa, maf.listw, scannf = FALSE, nfposi = 2, nfnega = 2)
+     maf.coa.ms
+     
+     ### detail eigenvalues components
+     fgraph <- function(obj){
+       # use multispati summary
+       sum.obj <- summary(obj)
+       # compute Imin and Imax
+       Ibounds <- moran.bounds(eval(as.list(obj$call)$listw))
+       Imin <- Ibounds[1]
+       Imax <- Ibounds[2]
+       I0 <- -1/(nrow(obj$li)-1)
+       # create labels
+       labels <- lapply(1:length(obj$eig),function(i) bquote(lambda[.(i)]))
+       # draw the plot
+       xmax <- eval(as.list(obj$call)$dudi)$eig[1]*1.1
+       oldpar <- par(las=1)
+       var <- sum.obj[,2]
+       moran <- sum.obj[,3]
+       plot(x=var,y=moran,type='n',xlab='Inertia',ylab="Spatial autocorrelation (I)",
+            xlim=c(0,xmax),ylim=c(Imin*1.1,Imax*1.1),yaxt='n')
+       text(x=var,y=moran,do.call(expression,labels))
+       ytick <- c(I0,round(seq(Imin,Imax,le=5),1))
+       ytlab <- as.character(round(seq(Imin,Imax,le=5),1))
+       ytlab <- c(as.character(round(I0,1)),as.character(round(Imin,1)),
+            ytlab[2:4],as.character(round(Imax,1)))
+       axis(side=2,at=ytick,labels=ytlab)
+       rect(0,Imin,xmax,Imax,lty=2)
+       segments(0,I0,xmax,I0,lty=2)
+       abline(v=0)
+       title("Spatial and inertia components of the eigenvalues")
+       par(oldpar)
+     }
+     fgraph(maf.coa.ms)
+     ## end eigenvalues details
+ 
+ 
+     if(adegraphicsLoaded()) {
+       g2 <- s1d.barchart(maf.coa$eig, p1d.hori = FALSE, plot = FALSE)
+       g3 <- s1d.barchart(maf.coa.ms$eig, p1d.hori = FALSE, plot = FALSE) 
+       g4 <- s.corcircle(maf.coa.ms$as, plot = FALSE)
+       G1 <- ADEgS(list(g2, g3, g4), layout = c(1, 3))
+     } else {
+       oldpar <- par(mfrow = c(1, 3))
+       barplot(maf.coa$eig)
+       barplot(maf.coa.ms$eig) 
+       s.corcircle(maf.coa.ms$as)
+       par(oldpar)
+     }
+  
+  
+     if(adegraphicsLoaded()) {
+       g5 <- s.value(maf.xy, -maf.coa$li[, 1], plot = FALSE)
+       g6 <- s.value(maf.xy, -maf.coa$li[, 2], plot = FALSE)
+       g7 <- s.value(maf.xy, maf.coa.ms$li[, 1], plot = FALSE)
+       g8 <- s.value(maf.xy, maf.coa.ms$li[, 2], plot = FALSE)
+       G2 <- ADEgS(list(g5, g6, g7, g8), layout = c(2, 2))
+     } else {
+       oldpar <- par(mfrow = c(2, 2))
+       s.value(maf.xy, -maf.coa$li[, 1])
+       s.value(maf.xy, -maf.coa$li[, 2])
+       s.value(maf.xy, maf.coa.ms$li[, 1])
+       s.value(maf.xy, maf.coa.ms$li[, 2])
+       par(oldpar)
+     }
+ 
+ 
+     w1 <- -maf.coa$li[, 1:2]
+     w1m <- apply(w1, 2, lag.listw, x = maf.listw)
+     w1.ms <- maf.coa.ms$li[, 1:2]
+     w1.msm <- apply(w1.ms, 2, lag.listw, x = maf.listw)
+     if(adegraphicsLoaded()) {
+       g9 <- s.match(w1, w1m, plab.cex = 0.75, plot = FALSE)
+       g10 <- s.match(w1.ms, w1.msm, plab.cex = 0.75, plot = FALSE)
+       G3 <- cbindADEg(g9, g10, plot = TRUE)
+     } else {
+       oldpar <- par(mfrow = c(1,2))
+       s.match(w1, w1m, clab = 0.75)
+       s.match(w1.ms, w1.msm, clab = 0.75)
+       par(oldpar)
+     }
+ 
+     maf.pca <- dudi.pca(mafragh$env, scannf = FALSE)
+     multispati.randtest(maf.pca, maf.listw)
+     maf.pca.ms <- multispati(maf.pca, maf.listw, scannf=FALSE)
+     plot(maf.pca.ms)
+ }
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘ade4’

The following object is masked from ‘package:spdep’:

    mstree

The following object is masked from ‘package:adespatial’:

    multispati

Warning in multispati(maf.coa, maf.listw, scannf = FALSE, nfposi = 2, nfnega = 2) :
  This function is now deprecated. Please use the 'multispati' function in the 'adespatial' package.

Multivariate Spatial Analysis
Call: multispati(dudi = maf.coa, listw = maf.listw, scannf = FALSE, 
    nfposi = 2, nfnega = 2)

Scores from the initial duality diagram:
          var       cum     ratio     moran
RS1 0.8691476 0.8691476 0.1043473 0.7250457
RS2 0.6491089 1.5182565 0.1822775 0.4834366

Multispati eigenvalues decomposition:
             eig       var      moran
CS1   0.68545912 0.8332937  0.8225901
CS2   0.37853390 0.5865926  0.6453097
CS54 -0.08077788 0.2482426 -0.3253990
CS55 -0.08900757 0.2749796 -0.3236879
Warning in multispati(maf.pca, maf.listw, scannf = FALSE) :
  This function is now deprecated. Please use the 'multispati' function in the 'adespatial' package.
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("multispati", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:ade4’, ‘package:spdep’, ‘package:sf’,
  ‘package:spData’

> nameEx("ortho.AIC")
> ### * ortho.AIC
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ortho.AIC
> ### Title: Compute AIC for models with orthonormal explanatory variables
> ### Aliases: ortho.AIC
> ### Keywords: models
> 
> ### ** Examples
> 
> 
> y <- matrix(rnorm(50),50,1)
> x <- svd(scale(y %*% c(0.1,0.5,2,0,0.7)+matrix(rnorm(250),50,5)))$u
> res <- ortho.AIC(y,x,ord.var=TRUE)
Warning in ortho.AIC(y, x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
> minAIC <- which.min(res$AICc)
> nvar <- length(1:minAIC)+1 # number of orthogonal vectors + 1 for intercept
> lm1 <- lm(y~x[,res$ord[1:minAIC]])
> summary(lm1)$r.squared # R2
[1] 0.7349473
> res$R2[minAIC] # the same
[1] 0.7349473
> min(res$AICc) # corrected AIC
[1] -76.97774
> extractAIC(lm1) # classical AIC
[1]   4.00000 -77.86663
> min(res$AICc)-2*(nvar*(nvar+1))/(nrow(x)-nvar-1) # the same
[1] -77.86663
> 
> lm2 <- lm(y~1)
> 
> res$AICc0 # corrected AIC for the null model
[1] -17.39196
> extractAIC(lm2) # classical AIC
[1]   1.00000 -17.47529
> res$AICc0-2*(1*(1+1))/(nrow(x)-1-1) # the same
[1] -17.47529
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ortho.AIC", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("orthobasis.poly")
> ### * orthobasis.poly
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: orthobasis.poly
> ### Title: Function to compute polynomial of geographical coordinates
> ### Aliases: orthobasis.poly
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require("ade4", quietly = TRUE)){
+ data(mafragh, package = "ade4")
+ pol2 <- orthobasis.poly(mafragh$Spatial) 
+ 
+ if(require("adegraphics", quietly = TRUE)){
+ plot(pol2, mafragh$Spatial)
+ }
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati


Attaching package: ‘adegraphics’

The following objects are masked from ‘package:ade4’:

    kplotsepan.coa, s.arrow, s.class, s.corcircle, s.distri, s.image,
    s.label, s.logo, s.match, s.traject, s.value, table.value,
    triangle.class

> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("orthobasis.poly", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:adegraphics’, ‘package:ade4’

> nameEx("plot.TBI")
> ### * plot.TBI
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.TBI
> ### Title: Plots of the outputs of a temporal beta diversity analysis
> ### Aliases: plot.TBI
> 
> ### ** Examples
> 
> 
> if(require("vegan", quietly = TRUE)) {
+ 
+ ## Example 1 -
+ 
+ ## Invertebrate communities subjected to insecticide treatment.
+ 
+ ## As an example in their paper on Principal Response Curves (PRC method), van den 
+ ## Brink & ter Braak (1999) used observations on the abundances of 178 invertebrate 
+ ## species (macroinvertebrates and zooplankton) subjected to treatments in 12 mesocosms 
+ ## by the insecticide chlorpyrifos. The mesocosms were sampled at 11 occasions. The 
+ ## data, available in the {vegan} package, are log-transformed species abundances, 
+ ## ytranformed = loge(10*y+1).
+ 
+ ## The data of survey #4 will be compared to those of survey #11 in this example. 
+ ## Survey #4 was carried out one week after the insecticide treatment, whereas the  
+ ## fauna of the mesocosms was considered by the authors to have fully recovered from  
+ ## the insecticide treatment at survey #11.
+ 
+ data(pyrifos)
+ 
+ ## The mesocosms had originally been attributed at random to the treatments. However, 
+ ## to facilitate presentation of the results, they will be listed here in order of 
+ ## increased insecticide doses: {0, 0, 0, 0, 0.1, 0.1, 0.9, 0.9, 6, 6, 44, 44} 
+ ## micro g/L.
+ 
+ ## Select the 12 data rows of surveys 4 and 11 from the data file and reorder them
+ 
+ ord4 <- c(38,39,41,47,37,44,40,46,43,48,42,45)
+ ord11 <- c(122,123,125,131,121,128,124,130,127,132,126,129)
+ 
+ ## Run the TBI function
+ 
+ res1 <- TBI(pyrifos[ord4,], pyrifos[ord11,], method = "%diff", nperm = 0, test.t.perm = FALSE)
+ 
+ res1$BCD.mat
+ 
+ ## Draw BC plots
+ 
+ oldpar <- par(mfrow=c(1,2))
+ 
+ s.names <- paste("Surv",1:12,sep=".")
+ 
+ ## In the 1st plot, the symbols have diameters proportional to the site TBI statistics 
+ 
+ plot(res1, s.names=s.names, col.bg="red", pch.loss=21, pch.gain=22, 
+ main="B-C plot, Pyrifos, surveys 4 & 11")
+ 
+ ## In the 2nd plot, control the axes limit values by specifying xlim and ylim
+ 
+ plot(res1, s.names=1:12, col.bg="green", pch.loss=23, pch.gain=24, 
+ main="B-C plot, Pyrifos, surveys 4 & 11", xlim=c(0,0.5), ylim=c(0.1,0.6))
+ 
+ ## In the 3rd plot, draw all symbols small and of the same size, using cex.symb=NULL
+ 
+ par(oldpar)
+ 
+ plot(res1, s.names=1:12, col.bg="gold", pch.loss=23, pch.gain=24, 
+ main="B-C plot, Pyrifos, surveys 4 & 11", cex.symb=NULL)
+ 
+ ## Example 2 -
+ 
+ ## This example uses the mite data available in vegan. Let us pretend that sites 1-20 
+ ## represent a survey at time 1 (T1) and sites 21-40 a survey at time 2 (T2).
+ 
+ data(mite)
+ 
+ ## Run the TBI function
+ 
+ res2 <- TBI(mite[1:20,],mite[21:40,],method="%diff",nperm=0,test.t.perm=FALSE)
+ 
+ res2$BCD.mat
+ 
+ ## Draw BC plots
+ 
+ oldpar <- par(mfrow=c(1,2))
+ 
+ s.names=rownames(res2$BCD.mat)
+ 
+ ## In the 1st plot, the symbols have diameters proportional to the site TBI statistics
+ 
+ plot(res2, s.names=s.names, col.bg="cadetblue2", pch.loss=21, pch.gain=22, 
+ main="B-C plot, Mite data")
+ 
+ # In the 2nd plot, control the axes limit values by specifying xlim and ylim
+ 
+ plot(res2, s.names=1:20, col.rim="coral2", pch.loss=19, pch.gain=15, 
+ main="B-C plot, Mite data", xlim=c(0,0.6), ylim=c(0,0.6))
+ par(oldpar)
+ }
This is vegan 2.6-6.1
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.TBI", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("plot.constr.hclust")
> ### * plot.constr.hclust
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.constr.hclust
> ### Title: Plotting Method For Space- And Time-Constrained Clustering
> ### Aliases: plot.constr.hclust
> 
> ### ** Examples
> 
> 
> ## Artificial map data from Legendre & Legendre (2012, Fig. 13.26)
> ## n = 16
> 
> dat <- c(41,42,25,38,50,30,41,43,43,41,30,50,38,25,42,41)
> coord.dat <- matrix(c(1,3,5,7,2,4,6,8,1,3,5,7,2,4,6,8,
+                       4.4,4.4,4.4,4.4,3.3,3.3,3.3,3.3,
+                       2.2,2.2,2.2,2.2,1.1,1.1,1.1,1.1),16,2)
> 
> ## Obtaining a list of neighbours:
> library(spdep)
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE
> listW <- nb2listw(tri2nb(coord.dat), style="B")
> links.mat.dat <- listw2mat(listW)
> neighbors <- listw2sn(listW)[,1:2]
> 
> ## Calculating the (Euclidean) distance between points:
> D.dat <- dist(dat)
> 
> ## Display the points:
> plot(coord.dat, type='n',asp=1)
> title("Delaunay triangulation")
> text(coord.dat, labels=as.character(as.matrix(dat)), pos=3)
> for(i in 1:nrow(neighbors))
+     lines(rbind(coord.dat[neighbors[i,1],],
+           coord.dat[neighbors[i,2],]))
> 
> ## Clustering with a contiguity constraint described by a list of
> ## links:
> grpWD2cst_constr_hclust <-
+     constr.hclust(
+         D.dat, method="ward.D2",
+         neighbors, coord.dat)
> 
> ## Plot the results with k=5 clusters on a map:
> plot(grpWD2cst_constr_hclust, k=5, links=TRUE, las=1,
+      xlab="Eastings", ylab="Northings", cex=3, lwd=3)
> 
> ## Repeat the plot with other values of k (number of groups)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.constr.hclust", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’

> nameEx("plot.orthobasisSp")
> ### * plot.orthobasisSp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.orthobasisSp
> ### Title: Function to display Moran's Eigenvector Maps (MEM) and other
> ###   spatial orthogonal bases
> ### Aliases: plot.orthobasisSp
> 
> ### ** Examples
> 
> if(require("ade4", quietly = TRUE) & require("spdep", quietly = TRUE)){
+ data(mafragh)
+ me <- mem(nb2listw(mafragh$nb))
+ 
+ if(require("adegraphics", quietly = TRUE)){
+ plot(me[,1:6], mafragh$xy)
+ plot(me[,1:6], mafragh$Spatial) 
+ }
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree


Attaching package: ‘adegraphics’

The following objects are masked from ‘package:ade4’:

    kplotsepan.coa, s.arrow, s.class, s.corcircle, s.distri, s.image,
    s.label, s.logo, s.match, s.traject, s.value, table.value,
    triangle.class

>         
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.orthobasisSp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:adegraphics’, ‘package:spdep’, ‘package:sf’,
  ‘package:spData’, ‘package:ade4’

> nameEx("rotation")
> ### * rotation
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rotation
> ### Title: Rotate a set of point by a certain angle
> ### Aliases: rotation
> ### Keywords: manip
> 
> ### ** Examples
> 
> 
> ### Create a set of coordinates
> coords<-cbind(runif(20),runif(20))
> 
> ### Create a series of angles
> rad<-seq(0,pi,l=20)
> 
> for(i in rad){
+ 	coords.rot<-rotation(coords,i)
+ 	plot(coords.rot)
+ }
> 
> ### Rotate the coordinates by an angle of 90 degrees
> coords.90<-rotation(coords,90*pi/180)
> coords.90
             [,1]       [,2]
 [1,] -0.93470523 0.26550866
 [2,] -0.21214252 0.37212390
 [3,] -0.65167377 0.57285336
 [4,] -0.12555510 0.90820779
 [5,] -0.26722067 0.20168193
 [6,] -0.38611409 0.89838968
 [7,] -0.01339033 0.94467527
 [8,] -0.38238796 0.66079779
 [9,] -0.86969085 0.62911404
[10,] -0.34034900 0.06178627
[11,] -0.48208012 0.20597457
[12,] -0.59956583 0.17655675
[13,] -0.49354131 0.68702285
[14,] -0.18621760 0.38410372
[15,] -0.82737332 0.76984142
[16,] -0.66846674 0.49769924
[17,] -0.79423986 0.71761851
[18,] -0.10794363 0.99190609
[19,] -0.72371095 0.38003518
[20,] -0.41127443 0.77744522
> 
> plot(coords,xlim=range(rbind(coords.90,coords)[,1]),ylim=range(rbind(coords.90,coords)[,2]),asp=1)
> points(coords.90,pch=19)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rotation", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("scalogram")
> ### * scalogram
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: scalogram
> ### Title: Function to compute a scalogram
> ### Aliases: scalogram plot.scalogram
> ### Keywords: spatial
> 
> ### ** Examples
> 
> if(require("ade4", quietly = TRUE) & require("spdep", quietly = TRUE)){
+ data(mafragh)
+ me <- mem(nb2listw(mafragh$nb))
+ 
+ if(require("adegraphics", quietly = TRUE)){
+ sc1 <- scalogram(mafragh$env$Conduc, me, nblocks = 10)
+ plot(sc1) 
+ }
+ }

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree


Attaching package: ‘adegraphics’

The following objects are masked from ‘package:ade4’:

    kplotsepan.coa, s.arrow, s.class, s.corcircle, s.distri, s.image,
    s.label, s.logo, s.match, s.traject, s.value, table.value,
    triangle.class

>  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("scalogram", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:adegraphics’, ‘package:spdep’, ‘package:sf’,
  ‘package:spData’, ‘package:ade4’

> nameEx("stimodels")
> ### * stimodels
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stimodels
> ### Title: Space-time interaction in ANOVA without replication
> ### Aliases: stimodels quicksti
> ### Keywords: multivariate spatial
> 
> ### ** Examples
> 
> # The "trichoptera" data set contains the abundances of 56 Trichoptera species captured 
> # during 100 consecutive days in 22 emergence traps along a stream. The 22 traps 
> # (sites) form a regular transect, with geographic positions 1 to 22. The original 
> # daily data collected at each site were pooled into 10 survey periods for the study 
> # of Legendre et al. (2010) in order to reduce the very high proportion of zeros in the 
> # original data matrix. Order of the observations in the data set: the 22 traps (sites) 
> # are nested within the survey weeks, as required by the 'stimodels' and 'quicksti' 
> # functions.
> 
> data(trichoptera)
> 
> # log-transform the species data, excluding the Site and Date colums
> 
> trich.log <- log1p(trichoptera[,-c(1,2)]) 
> 
> # A log-chord transformation (Legendre & Borcard 2018) would also be appropriate for 
> # these data: trich.tr <- decostand(log1p(trichoptera[,-c(1,2)]), method="norm")
> 
> # Example 1. Compute the space-time interaction test using model 5. By specifying the  
> # number of sites (traps), the sofware assumes that they form a regular transect with  
> # equispaced sites. Important note to users – In real analyses, use more than 99 
> # permutations.
> 
> out.1 <- stimodels(trich.log, S=22, Ti=10, model="5", nperm=99)
=======================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
=======================================================

 Number of space points (s) = 22 
 Number of time points (tt) = 10 
 Number of observations (n = s*tt) = 220 
 Number of response variables (p) = 56 
 
 Computing dbMEMs to code for space
 Truncation level for space dbMEMs = 1 
 Computing dbMEMs to code for time
 Truncation level for time dbMEMs = 1 

 Number of space coding functions = 10 

 Number of time coding functions = 4 

 MODEL V: HELMERT CONTRAST FOR TESTING MAIN FACTORS.
          SPACE AND TIME dbMEMs FOR TESTING INTERACTION.
   Number of space variables = 21 
   Number of time variables = 9 
   Number of interaction variables = 40 
   Number of residual degrees of freedom = 149 

 Interaction test:   R2 = 0.1809   F = 2.9235   P( 99 perm) = 0.01 
 Space test:         R2 = 0.2809   F = 8.6459   P( 99 perm) = 0.01 
 Time test:          R2 = 0.3076   F = 22.0858   P( 99 perm) = 0.01 

-------------------------------------------------------
         Time for computation = 2.133000  sec 
=======================================================

> 
> # The interaction is significant. Because of that, test results for the main effects, 
> # space and time, obtained with model 5, cannot be interpreted. Tests of spatial 
> # variation can be done for individual times using simple RDA against dbMEM.S  
> # variables. Likewise, tests of temporal variation can be done for individual sites  
> # using simple RDA against dbMEM.T variables. A global test of the hypothesis that none 
> # of the times shows a significant spatial structure can be done with model 6a. For a  
> # global test of temporal structure at the various sites, use model 6b.
> 
> ## No test: 
>      # Code not run during CRAN software tests
> 
> # Example 2. Run space-time analysis with global tests for main effects after testing
> # the interaction, which is significant in this example 
> 
> out.2 <- quicksti(trich.log, S=22, Ti=10, nperm=999)
=========================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
---------------------------------------------------------

 Number of space points (s) = 22 
 Number of time points (tt) = 10 
 Number of observations (n = s*tt) = 220 
 Number of response variables (p) = 56 
 Significance level for the interaction test (alpha) = 0.05 
 
 Computing dbMEMs to code for space
 Truncation level for space dbMEMs = 1 
 Computing dbMEMs to code for time
 Truncation level for time dbMEMs = 1 

 Number of space coding functions = 10 
 Number of time coding functions = 4 

------------------------------------------
 Testing space-time interaction (model 5)
------------------------------------------

   Number of space variables = 21 
   Number of time variables = 9 
   Number of interaction variables = 40 
   Number of residual degrees of freedom = 149 

 Interaction test:  R2 = 0.1809   F = 2.9235   P( 999 perm) = 0.001 
----------------------------------------------------
 Testing for separate spatial structures (model 6a)
----------------------------------------------------

   Number of space variables = 100 
   Number of time variables = 9 
   Number of residual degrees of freedom = 110 

 Space test:  R2 = 0.4666   F = 2.2733   P( 999 perm) = 0.001 
-----------------------------------------------------
 Testing for separate temporal structures (model 6b)
-----------------------------------------------------

   Number of space variables = 21 
   Number of time variables = 88 
   Number of residual degrees of freedom = 110 

 Time test:   R2 = 0.5265   F = 3.4186   P( 999 perm) = 0.001 

---------------------------------------------------------
          Time for computation = 25.793000  sec 
=========================================================

> 
> # Since the interaction is significant, function 'quicksti' will carry out the 
> # tests of existence of a spatial (at least in one of the time periods) and temporal 
> # (at least at one of the sites) structures using models 6a and 6b, respectively.
> 
> # 3. Run space-time analysis for two time blocks only, i.e. time periods 6 and 7,   
> # then time periods 8 and 9.
> 
> # Example 3.1. Time periods 6 and 7. The interaction is not significant. In that case,  
> # function 'quicksti' carries out the tests of the main effects using model 5.
> 
> out.3 <- quicksti(trich.log[111:154,], S=22, Ti=2, nperm=999)
=========================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
---------------------------------------------------------

 Number of space points (s) = 22 
 Number of time points (tt) = 2 
 Number of observations (n = s*tt) = 44 
 Number of response variables (p) = 56 
 Significance level for the interaction test (alpha) = 0.05 
 
 Computing dbMEMs to code for space
 Truncation level for space dbMEMs = 1 
 Computing dbMEMs to code for time

 There are only two time points. A vector of Helmert contrasts will be used to represent them

 Number of space coding functions = 10 
 Number of time coding functions = 1 

------------------------------------------
 Testing space-time interaction (model 5)
------------------------------------------

   Number of space variables = 21 
   Number of time variables = 1 
   Number of interaction variables = 10 
   Number of residual degrees of freedom = 11 

 Interaction test:  R2 = 0.0755   F = 1.1814   P( 999 perm) = 0.227 
---------------------------------------------------------------------
 Testing for common spatial and common temporal structures (model 5)
---------------------------------------------------------------------

 Space test:   R2 = 0.8091   F = 6.026   P( 999 perm) = 0.001 
 Time test:    R2 = 0.045   F = 7.045   P( 999 perm) = 0.001 

---------------------------------------------------------
          Time for computation = 1.580000  sec 
=========================================================

> 
> # Example 3.2. Time periods 8 and 9. The interaction is significant. In that case,  
> # 'quicksti' carries out the tests of the spatial effects using model 6a. Model 6b 
> # cannot proceed with the test of the temporal effect because Ti=2. An explanation is 
> # printed in the output list.
> 
> out.4 <- quicksti(trich.log[155:198,], S=22, Ti=2, nperm=999)
=========================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
---------------------------------------------------------

 Number of space points (s) = 22 
 Number of time points (tt) = 2 
 Number of observations (n = s*tt) = 44 
 Number of response variables (p) = 56 
 Significance level for the interaction test (alpha) = 0.05 
 
 Computing dbMEMs to code for space
 Truncation level for space dbMEMs = 1 
 Computing dbMEMs to code for time

 There are only two time points. A vector of Helmert contrasts will be used to represent them

 Number of space coding functions = 10 
 Number of time coding functions = 1 

------------------------------------------
 Testing space-time interaction (model 5)
------------------------------------------

   Number of space variables = 21 
   Number of time variables = 1 
   Number of interaction variables = 10 
   Number of residual degrees of freedom = 11 

 Interaction test:  R2 = 0.1476   F = 1.5921   P( 999 perm) = 0.013 
----------------------------------------------------
 Testing for separate spatial structures (model 6a)
----------------------------------------------------

   Number of space variables = 20 
   Number of time variables = 1 
   Number of residual degrees of freedom = 22 

 Space test:  R2 = 0.6234   F = 2.1679   P( 999 perm) = 0.001 
-----------------------------------------------------
 Testing for separate temporal structures (model 6b)
-----------------------------------------------------

   Number of space variables = 21 
   Number of time variables = 22 
   Number of residual degrees of freedom = 0 

Model 6b requires that 'tt' be larger than 2. When tt=2, full coding of the times by a binary variable or Helmert contrast does not leave any degree of freedom for the residuals in the test of the Time factor.

---------------------------------------------------------
          Time for computation = 1.957000  sec 
=========================================================

> 
> # 4. Illustrations of the use of 'COD.S' and 'COD.T' in STI analysis
> 
> # The following examples illustrate how to use other representations of the spatial or 
> # temporal relationships among observations, through arguments 'COD.S' and 
> # 'COD.T' of functions 'stimodels' and 'quicksti'. The trichoptera data 
> # are used again.
> 
> # Example 4.1. Explicitly compute dbMEMs for the spatial structure along the regular 
> # transect, using function 'dbmem' of adespatial, and provide it to 'stimodels' 
> # or 'quicksti' as argument 'COD.S'. The dbMEMs must first be computed on the
> # transect, then repeated (Ti-1) times to provide Ti repeats in total.
> 
> dbMEM.S1 <- as.matrix(dbmem(1:22))
> dbMEM.S10 <- dbMEM.S1
> for(j in 2:10) dbMEM.S10 <- rbind(dbMEM.S10, dbMEM.S1)
> out.5 <- stimodels(trich.log, S=22, Ti=10, model="5", COD.S=dbMEM.S10, nperm=999)
=======================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
=======================================================

 Number of space points (s) = 22 
 Number of time points (tt) = 10 
 Number of observations (n = s*tt) = 220 
 Number of response variables (p) = 56 
 
 Computing dbMEMs to code for time
 Truncation level for time dbMEMs = 1 

 Number of space coding functions = 10 

 Number of time coding functions = 4 

 MODEL V: HELMERT CONTRAST FOR TESTING MAIN FACTORS.
          SPACE AND TIME dbMEMs FOR TESTING INTERACTION.
   Number of space variables = 21 
   Number of time variables = 9 
   Number of interaction variables = 40 
   Number of residual degrees of freedom = 149 

 Interaction test:   R2 = 0.1809   F = 2.9235   P( 999 perm) = 0.001 
 Space test:         R2 = 0.2809   F = 8.6459   P( 999 perm) = 0.001 
 Time test:          R2 = 0.3076   F = 22.0858   P( 999 perm) = 0.001 

-------------------------------------------------------
         Time for computation = 14.938000  sec 
=======================================================

> 
> # Results should be identical to those in output file out.1 of Example 1, except for 
> # P-values which can vary slightly.
> 
> # Example 4.2. Assume now that the sampling sites have irregular positions, as 
> # described by the following matrix of geographic coordinates 'xy.trich'. Provide 
> # this matrix to argument S of 'stimodels'
> 
> xy.trich = matrix(c(1:5,11:15,21:25,31:35,41,42,rep(c(1,2),11)),22,2)
> plot(xy.trich, asp=1)   # Plot a quick map of the site positions
> out.6 <- stimodels(trich.log, S=xy.trich, Ti=10, model="5", nperm=999)
=======================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
=======================================================

 Number of space points (s) = 22 
 Number of time points (tt) = 10 
 Number of observations (n = s*tt) = 220 
 Number of response variables (p) = 56 
 
 Computing dbMEMs to code for space
 Truncation level for space dbMEMs = 6.082763 
 Computing dbMEMs to code for time
 Truncation level for time dbMEMs = 1 

 Number of space coding functions = 4 

 Number of time coding functions = 4 

 MODEL V: HELMERT CONTRAST FOR TESTING MAIN FACTORS.
          SPACE AND TIME dbMEMs FOR TESTING INTERACTION.
   Number of space variables = 21 
   Number of time variables = 9 
   Number of interaction variables = 16 
   Number of residual degrees of freedom = 173 

 Interaction test:   R2 = 0.0972   F = 3.343   P( 999 perm) = 0.001 
 Space test:         R2 = 0.2809   F = 7.3632   P( 999 perm) = 0.001 
 Time test:          R2 = 0.3076   F = 18.8093   P( 999 perm) = 0.001 

-------------------------------------------------------
         Time for computation = 15.164000  sec 
=======================================================

> 
> # Example 4.3. Compute a matrix of dbMEMs for the sites. The coding matrix provided to 
> # argument 'COD.S' must contain repeated dbMEM.S codes because that matrix must have 
> # the same number of rows as matrix Y. Construct coding matrix dbMEM.S10 containing the 
> # dbMEM.S codes repeated 10 times. 
> 
> dbMEM.S1 <- as.matrix(dbmem(xy.trich))
> dbMEM.S10 = dbMEM.S1
> for(i in 1:9) dbMEM.S10 <- rbind(dbMEM.S10, dbMEM.S1)
> out.7 <- stimodels(trich.log, S=22, Ti=10, model="5", COD.S=dbMEM.S10, nperm=999)
=======================================================
        Space-time ANOVA without replicates
                                                  
  Pierre Legendre, Miquel De Caceres, Daniel Borcard
=======================================================

 Number of space points (s) = 22 
 Number of time points (tt) = 10 
 Number of observations (n = s*tt) = 220 
 Number of response variables (p) = 56 
 
 Computing dbMEMs to code for time
 Truncation level for time dbMEMs = 1 

 Number of space coding functions = 4 

 Number of time coding functions = 4 

 MODEL V: HELMERT CONTRAST FOR TESTING MAIN FACTORS.
          SPACE AND TIME dbMEMs FOR TESTING INTERACTION.
   Number of space variables = 21 
   Number of time variables = 9 
   Number of interaction variables = 16 
   Number of residual degrees of freedom = 173 

 Interaction test:   R2 = 0.0972   F = 3.343   P( 999 perm) = 0.001 
 Space test:         R2 = 0.2809   F = 7.3632   P( 999 perm) = 0.001 
 Time test:          R2 = 0.3076   F = 18.8093   P( 999 perm) = 0.001 

-------------------------------------------------------
         Time for computation = 15.239000  sec 
=======================================================

> 
> # Compare the results with those obtained in the output file out6, example 4.2.
> 
> # Careful: If an analysis requires a dbMEM coding matrix for 'COD.T', the dbMEM.T    
> # codes must follow the required data arrangement: sites must be nested within times.
> # The following function can be used to construct a dbMEM.T matrix.
> 
> MEM.T <- function(s, tt, coord.T=NULL)
+   # Documentation of function MEM.T –
+  # Generate a matrix of temporal eigenfunctions for input into stimodels, 
+  # with sites nested within times.
+  # Arguments –
+  # s : number of space points (sites)
+  # tt : number of time points
+  # coord.T : optional matrix or vector giving the time point coordinates
+   {
+   n <- s*tt
+   if(is.null(coord.T)) coord.T <- as.matrix(1:tt)
+   MEM.TT <- as.matrix(dbmem(coord.T))
+   dbMEM.T <- matrix(0,n,ncol(MEM.TT))    # Empty matrix to house dbMEM.T		
+   beg.x <- seq(1, n, by=s)
+   for(i in 1:tt) { # Fill tt blocks of rows with identical MEM.TT values
+ 	  for(j in 1:s) dbMEM.T[(beg.x[i]+j-1),] <- MEM.TT[i,]
+ 	  }
+   dbMEM.T
+   }
> 
> # Example of use of function MEM.T
>  
> dbMEM.T <- MEM.T(s=6, tt=5)
> # Check the size of the dbMEM.T output matrix
> dim(dbMEM.T)
[1] 30  2
> 
> ## End(No test)
>    # End of code not run during CRAN software tests
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stimodels", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("test.W")
> ### * test.W
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: test.W
> ### Title: Function to compute and test eigenvectors of spatial weighting
> ###   matrices
> ### Aliases: test.W
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require(ade4) & require(spdep)){
+ 
+ data(oribatid)
+ # Hellinger transformation
+ fau <- sqrt(oribatid$fau / outer(apply(oribatid$fau, 1, sum), rep(1, ncol(oribatid$fau)), "*"))
+ # remove gradient effect
+ faudt <- resid(lm(as.matrix(fau) ~ as.matrix(oribatid$xy)))
+ 
+ # test a binary spatial weighting matrix
+ nbtri <- tri2nb(as.matrix(oribatid$xy))
+ tri.res <- test.W(faudt, nbtri)
+ 
+ maxi <- max(unlist(nbdists(nbtri, as.matrix(oribatid$xy))))
+ 
+ # test a simple spatial weighting function of the distance
+ f1 <- function(x) {1-(x)/(maxi)}
+ tri.f1 <- test.W(faudt, nbtri, f = f1, xy = as.matrix(oribatid$xy))
+ 
+ # test a spatial weighting function with various values of parameters
+ f2 <- function(x,dmax,y) {1-(x^y)/(dmax)^y}
+ tri.f2 <- test.W(faudt,nbtri, f = f2, y = 2:10, dmax = maxi, xy = as.matrix(oribatid$xy))
+ }
Loading required package: ade4

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

Loading required package: spdep
Loading required package: spData
To access larger datasets in this package, install the spDataLarge
package with: `install.packages('spDataLarge',
repos='https://nowosad.github.io/drat/', type='source')`
Loading required package: sf
Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE

Attaching package: ‘spdep’

The following object is masked from ‘package:ade4’:

    mstree

Warning in test.W(faudt, nbtri) :
  This function is now deprecated. Please try the new 'listw.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.


AICc for the null model: -87.47112034786 

Best spatial model:
          AICc NbVar
MEM5 -94.18844     7
Warning in test.W(faudt, nbtri, f = f1, xy = as.matrix(oribatid$xy)) :
  This function is now deprecated. Please try the new 'listw.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.


AICc for the null model: -87.47112034786 

Best spatial model:
           AICc NbVar
MEM32 -95.48955     6
Warning in test.W(faudt, nbtri, f = f2, y = 2:10, dmax = maxi, xy = as.matrix(oribatid$xy)) :
  This function is now deprecated. Please try the new 'listw.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.
Warning in ortho.AIC(Y = Y, X = x, ord.var = TRUE) :
  This function is now deprecated. Please try the new 'mem.select' function.


AICc for the null model: -87.47112034786 

Best spatial model:
  y dmax      AICc NbVar
1 2    3 -95.44519     6
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("test.W", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:spdep’, ‘package:sf’, ‘package:spData’,
  ‘package:ade4’

> nameEx("tpaired.krandtest")
> ### * tpaired.krandtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tpaired.krandtest
> ### Title: Paired t-tests of differences between T1 and T2 for each species
> ### Aliases: tpaired.krandtest
> 
> ### ** Examples
> 
> 
> if(require("vegan", quietly = TRUE)) {
+ 
+ ## Invertebrate communities subjected to insecticide treatment.
+ 
+ ## As an example in their paper on Principal Response Curves (PRC), van den Brink & ter 
+ ## Braak (1999) used observations on the abundances of 178 invertebrate species 
+ ## (macroinvertebrates and zooplankton) subjected to treatments in 12 mesocosms by the 
+ ## insecticide chlorpyrifos. The mesocosms were sampled at 11 occasions. The data, 
+ ## available in the {vegan} package, are log-transformed species abundances, 
+ ## y.tranformed = loge(10*y+1).
+ 
+ ## The data of survey #4 will be compared to those of survey #11 in this example.  
+ ## Survey #4 was carried out one week after the insecticide treatment, whereas the 
+ ## fauna of the mesocosms was considered to have fully recovered from the treatment 
+ ## at the time of survey #11.
+ 
+ data(pyrifos)
+ 
+ ## The mesocosms had originally been attributed at random to the treatments. However,  
+ ## to facilitate presentation of the results, they will be listed here in order of 
+ ## increased insecticide doses: {0, 0, 0, 0, 0.1, 0.1, 0.9, 0.9, 6, 6, 44, 44} 
+ ## micro g/L.
+ 
+ survey4.order = c(38,39,41,47,37,44,40,46,43,48,42,45)
+ 
+ survey11.order = c(122,123,125,131,121,128,124,130,127,132,126,129)
+ 
+ ## Paired t-tests of differences between survey.4 and survey.11 for the p species
+ 
+ res <- tpaired.krandtest(pyrifos[survey4.order,],pyrifos[survey11.order,])
+ 
+ }
This is vegan 2.6-6.1
62 species were eliminated because they did not vary in the combined data set
116 species retained:
1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99  100  101  102  103  104  105  106  107  108  109  110  111  112  113  114  115  116  

3 species not tested because t.stat = 0. See 'No_test' output list

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tpaired.krandtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:vegan’, ‘package:lattice’, ‘package:permute’

> nameEx("tpaired.randtest")
> ### * tpaired.randtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tpaired.randtest
> ### Title: Permutational paired t-test
> ### Aliases: tpaired.randtest
> 
> ### ** Examples
> 
> 
> ## Deer leg length, data from Zar (1999, p. 162).
> 
> deer <- matrix(c(142,140,144,144,142,146,149,150,142,148,138,136,147,139,143,141,143,
+ 145,136,146),10,2)
> 
> rownames(deer) <- paste("Deer",1:10,sep=".")
> 
> colnames(deer) <- c('Hind.leg', 'Fore.leg')
> 
> res <- tpaired.randtest(deer[,1], deer[,2])   # Two-tailed test by default

t-test comparing the means of two related samples 
 
Number of objects: 10 
Mean of the differences: 3.3 
t statistic (paired observations): 3.413793 
95 percent confidence interval of t: 1.113248 5.486752 
Degrees of freedom: 9 
Alternative hypothesis: two.sided 
Prob (parametric): 0.007703223 
Prob ( 99 permutations): 0.01000 
> 
> ## Compare the results to:  res2 = t.test(deer[,1], deer[,2], paired=TRUE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tpaired.randtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("variogmultiv")
> ### * variogmultiv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: variogmultiv
> ### Title: Function to compute multivariate empirical variogram
> ### Aliases: variogmultiv
> ### Keywords: spatial
> 
> ### ** Examples
> 
> 
> if(require(ade4)){
+ data(oribatid)
+ # Hellinger transformation
+ fau <- sqrt(oribatid$fau / outer(apply(oribatid$fau, 1, sum), rep(1, ncol(oribatid$fau)), "*"))
+ # Removing linear effect
+ faudt <- resid(lm(as.matrix(fau) ~ as.matrix(oribatid$xy))) 
+ mvspec <- variogmultiv(faudt, oribatid$xy, nclass = 20)
+ mvspec
+ plot(mvspec$d, mvspec$var,type = 'b', pch = 20, xlab = "Distance", ylab = "C(distance)")
+ }
Loading required package: ade4

Attaching package: ‘ade4’

The following object is masked from ‘package:adespatial’:

    multispati

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("variogmultiv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:ade4’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  217.292 0.407 217.824 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
